<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PDFxTMDLib: node.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PDFxTMDLib
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b25a22f7b00b87357cc9b07c5deaa9da.html">PDFxTMDLib</a></li><li class="navelem"><a class="el" href="dir_809e8457d18effbd6edd50e706b928aa.html">external</a></li><li class="navelem"><a class="el" href="dir_dc6c7bf108877046db6f13990e4a05ed.html">fkYAML</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">node.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;initializer_list&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;deque&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;cstdarg&gt;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;istream&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;forward_list&gt;</code><br />
<code>#include &lt;valarray&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for node.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="node_8hpp__incl.png" border="0" usemap="#anode_8hpp" alt=""/></div>
<map name="anode_8hpp" id="anode_8hpp">
<area shape="rect" title=" " alt="" coords="1252,5,1335,32"/>
<area shape="rect" title=" " alt="" coords="5,80,91,107"/>
<area shape="rect" title=" " alt="" coords="115,80,181,107"/>
<area shape="rect" title=" " alt="" coords="205,80,272,107"/>
<area shape="rect" title=" " alt="" coords="297,80,407,107"/>
<area shape="rect" title=" " alt="" coords="432,80,483,107"/>
<area shape="rect" title=" " alt="" coords="507,80,584,107"/>
<area shape="rect" title=" " alt="" coords="608,80,667,107"/>
<area shape="rect" title=" " alt="" coords="691,80,783,107"/>
<area shape="rect" title=" " alt="" coords="807,80,870,107"/>
<area shape="rect" title=" " alt="" coords="895,80,964,107"/>
<area shape="rect" title=" " alt="" coords="989,80,1059,107"/>
<area shape="rect" title=" " alt="" coords="1083,80,1154,107"/>
<area shape="rect" title=" " alt="" coords="1179,80,1237,107"/>
<area shape="rect" title=" " alt="" coords="1262,80,1325,107"/>
<area shape="rect" title=" " alt="" coords="1349,80,1414,107"/>
<area shape="rect" title=" " alt="" coords="1438,80,1503,107"/>
<area shape="rect" title=" " alt="" coords="1528,80,1584,107"/>
<area shape="rect" title=" " alt="" coords="1609,80,1695,107"/>
<area shape="rect" title=" " alt="" coords="1719,80,1790,107"/>
<area shape="rect" title=" " alt="" coords="1815,80,1876,107"/>
<area shape="rect" title=" " alt="" coords="1901,80,1963,107"/>
<area shape="rect" title=" " alt="" coords="1988,80,2060,107"/>
<area shape="rect" title=" " alt="" coords="2085,80,2145,107"/>
<area shape="rect" title=" " alt="" coords="2169,80,2244,107"/>
<area shape="rect" title=" " alt="" coords="2268,80,2367,107"/>
<area shape="rect" title=" " alt="" coords="2391,80,2467,107"/>
<area shape="rect" title=" " alt="" coords="2491,80,2578,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="node_8hpp__dep__incl.png" border="0" usemap="#anode_8hppdep" alt=""/></div>
<map name="anode_8hppdep" id="anode_8hppdep">
<area shape="rect" title=" " alt="" coords="83,5,166,32"/>
<area shape="rect" href="ConfigWrapper_8h.html" title=" " alt="" coords="60,80,189,107"/>
<area shape="rect" href="YamlInfoReader_8h.html" title=" " alt="" coords="5,155,140,181"/>
<area shape="rect" href="GenericPDF_8h.html" title=" " alt="" coords="71,229,179,256"/>
<area shape="rect" href="Factory_8h.html" title=" " alt="" coords="85,304,164,331"/>
<area shape="rect" href="FortranFactoryWrapper_8h.html" title=" " alt="" coords="34,379,215,405"/>
</map>
</div>
</div>
<p><a href="node_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__null__pointer.html">is_null_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::is_null_pointer with C++11.  <a href="structis__null__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinteger__sequence.html">integer_sequence&lt; T, I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__int__seq__impl_1_1merger_3_01integer__sequence_3_01T_00_01Ints0_8_8_8_01_4_00_01inteb1460082dd6b13cd6f6f6c103e247377.html">make_int_seq_impl::merger&lt; integer_sequence&lt; T, Ints0... &gt;, integer_sequence&lt; T, Ints1... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__int__seq__impl_1_1generator.html">make_int_seq_impl::generator&lt; T, Num &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__int__seq__impl_1_1generator_3_01T_00_010_01_4.html">make_int_seq_impl::generator&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__int__seq__impl_1_1generator_3_01T_00_011_01_4.html">make_int_seq_impl::generator&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconjunction.html">conjunction&lt; Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::void_t with C++11/C++14.  <a href="structconjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconjunction_3_01Trait_01_4.html">conjunction&lt; Trait &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of conjunction if only one Trait is given.  <a href="structconjunction_3_01Trait_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconjunction_3_01First_00_01Rest_8_8_8_01_4.html">conjunction&lt; First, Rest... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of conjunction if more than one traits are given.  <a href="structconjunction_3_01First_00_01Rest_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdisjunction.html">disjunction&lt; Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::disjunction with C++11/C++14.  <a href="structdisjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdisjunction_3_01Trait_01_4.html">disjunction&lt; Trait &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of disjunction if only one Trait is given.  <a href="structdisjunction_3_01Trait_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdisjunction_3_01First_00_01Rest_8_8_8_01_4.html">disjunction&lt; First, Rest... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of disjunction if more than one traits are given.  <a href="structdisjunction_3_01First_00_01Rest_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnegation.html">negation&lt; Trait &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::negation with C++11/C++14.  <a href="structnegation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__void.html">make_void&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for void_t.  <a href="structmake__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnonesuch.html">nonesuch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy struct to represent detection failure.  <a href="structnonesuch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetector__impl_1_1detector.html">detector_impl::detector&lt; Default, AlwaysVoid, Op, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for general type detection.  <a href="structdetector__impl_1_1detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetector__impl_1_1detector_3_01Default_00_01void__t_3_01Op_3_01Args_8_8_8_01_4_01_4_00_01Op_00_01Args_8_8_8_01_4.html">detector_impl::detector&lt; Default, void_t&lt; Op&lt; Args... &gt; &gt;, Op, Args... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of detector if desired operation type is found.  <a href="structdetector__impl_1_1detector_3_01Default_00_01void__t_3_01Op_3_01Args_8_8_8_01_4_01_4_00_01Op_00_01Args_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetect_1_1is__iterator__traits.html">detect::is_iterator_traits&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T is a std::iterator_traits like type.  <a href="structdetect_1_1is__iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetect_1_1has__begin__end.html">detect::has_begin_end&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if begin/end functions can be called on a T object.  <a href="structdetect_1_1has__begin__end.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdetect_1_1has__begin__end_3_01T_00_01void__t_3_01decltype_07begin_07std_1_1declval_3_01T_05147605ecf9f2aeafb3c7c43d1928906.html">detect::has_begin_end&lt; T, void_t&lt; decltype(begin(std::declval&lt; T &gt;()), end(std::declval&lt; T &gt;()))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if begin/end functions can be called on a T object.  <a href="structdetect_1_1has__begin__end_3_01T_00_01void__t_3_01decltype_07begin_07std_1_1declval_3_01T_05147605ecf9f2aeafb3c7c43d1928906.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__comparable.html">is_comparable&lt; Comparator, T, U, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if T and U are comparable types.  <a href="structis__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__comparable_3_01Comparator_00_01T_00_01U_00_01void__t_3_01decltype_07std_1_1declval_3_06e562badaf5810058b4f5b03a9449f02.html">is_comparable&lt; Comparator, T, U, void_t&lt; decltype(std::declval&lt; Comparator &gt;()(std::declval&lt; T &gt;(), std::declval&lt; U &gt;())), decltype(std::declval&lt; Comparator &gt;()(std::declval&lt; U &gt;(), std::declval&lt; T &gt;()))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__comparable.html" title="Type trait to check if T and U are comparable types.">is_comparable</a> if T and U are comparable types.  <a href="structis__comparable_3_01Comparator_00_01T_00_01U_00_01void__t_3_01decltype_07std_1_1declval_3_06e562badaf5810058b4f5b03a9449f02.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__non__bool__integral.html">is_non_bool_integral&lt; IntegralType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if IntegralType is of non-boolean integral types.  <a href="structis__non__bool__integral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__non__bool__integral_3_01IntegralType_00_01enable__if__t_3_01conjunction_3_01std_1_1is_8ed9dc7e0c0df54899adcb76fa7b0a53.html">is_non_bool_integral&lt; IntegralType, enable_if_t&lt; conjunction&lt; std::is_integral&lt; IntegralType &gt;, negation&lt; std::is_same&lt; bool, IntegralType &gt; &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__non__bool__integral.html" title="Type trait to check if IntegralType is of non-boolean integral types.">is_non_bool_integral</a> if IntegralType is of non-boolean integral types.  <a href="structis__non__bool__integral_3_01IntegralType_00_01enable__if__t_3_01conjunction_3_01std_1_1is_8ed9dc7e0c0df54899adcb76fa7b0a53.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__compatible__integer__type__impl.html">is_compatible_integer_type_impl&lt; TargetIntegerType, CompatibleIntegerType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait implementation to check if TargetIntegerType and CompatibleIntegerType are compatible integer types.  <a href="structis__compatible__integer__type__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__compatible__integer__type__impl_3_01TargetIntegerType_00_01CompatibleIntegerType_00_0186cf35ce9c65b3667f641740783b8f90.html">is_compatible_integer_type_impl&lt; TargetIntegerType, CompatibleIntegerType, enable_if_t&lt; is_non_bool_integral&lt; CompatibleIntegerType &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__compatible__integer__type__impl.html" title="Type trait implementation to check if TargetIntegerType and CompatibleIntegerType are compatible inte...">is_compatible_integer_type_impl</a> if TargetIntegerType and CompatibleIntegerType are compatible integer types.  <a href="structis__compatible__integer__type__impl_3_01TargetIntegerType_00_01CompatibleIntegerType_00_0186cf35ce9c65b3667f641740783b8f90.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__compatible__integer__type.html">is_compatible_integer_type&lt; TargetIntegerType, CompatibleIntegerType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if TargetIntegerType and CompatibleIntegerType are compatible integer types.  <a href="structis__compatible__integer__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__complete__type.html">is_complete_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T is a complete type.  <a href="structis__complete__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__complete__type_3_01T_00_01decltype_07void_07sizeof_07T_08_08_08_4.html">is_complete_type&lt; T, decltype(void(sizeof(T)))&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__complete__type.html" title="Type traits to check if T is a complete type.">is_complete_type</a> if T is a complete type.  <a href="structis__complete__type_3_01T_00_01decltype_07void_07sizeof_07T_08_08_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstatic__const.html">static_const&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility struct to generate static constant instance.  <a href="structstatic__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtype__tag.html">type_tag&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper structure for tag dispatch.  <a href="structtype__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structget__head__type_3_4.html">get_head_type&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <a class="el" href="structget__head__type.html" title="A utility struct to retrieve the first type in variadic template arguments.">get_head_type</a> if variadic template has no arguments.  <a href="structget__head__type_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structget__head__type_3_01First_00_01Rest_8_8_8_01_4.html">get_head_type&lt; First, Rest... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structget__head__type.html" title="A utility struct to retrieve the first type in variadic template arguments.">get_head_type</a> if variadic template has one or more argument(s).  <a href="structget__head__type_3_01First_00_01Rest_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__basic__node.html">is_basic_node&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to check the template parameter class is a kind of <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template class.  <a href="structis__basic__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__basic__node_3_01basic__node_3_01SequenceType_00_01MappingType_00_01BooleanType_00_01In0703996a89677204d43422587c3486fa.html">is_basic_node&lt; basic_node&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, Converter &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__basic__node.html" title="A struct to check the template parameter class is a kind of basic_node template class.">is_basic_node</a> for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template class.  <a href="structis__basic__node_3_01basic__node_3_01SequenceType_00_01MappingType_00_01BooleanType_00_01In0703996a89677204d43422587c3486fa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__node__ref__storage.html">is_node_ref_storage&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to check the template parameter class is a kind of node_ref_storage_template class.  <a href="structis__node__ref__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__node__ref__storage_3_01node__ref__storage_3_01T_01_4_01_4.html">is_node_ref_storage&lt; node_ref_storage&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization for <a class="el" href="classnode__ref__storage.html" title="A temporal storage for basic_node class objects.">node_ref_storage</a> template class.  <a href="structis__node__ref__storage_3_01node__ref__storage_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__from__node.html">has_from_node&lt; BasicNodeType, T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T is a compatible type for BasicNodeType in terms of from_node function.  <a href="structhas__from__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__from__node_3_01BasicNodeType_00_01T_00_01enable__if__t_3_9is__basic__node_3_01T_01_4_1_1value_01_4_01_4.html">has_from_node&lt; BasicNodeType, T, enable_if_t&lt;!is_basic_node&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structhas__from__node.html" title="Type traits to check if T is a compatible type for BasicNodeType in terms of from_node function.">has_from_node</a> if T is not a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type.  <a href="structhas__from__node_3_01BasicNodeType_00_01T_00_01enable__if__t_3_9is__basic__node_3_01T_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__to__node.html">has_to_node&lt; BasicNodeType, T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T is a compatible type for BasicNodeType in terms of to_node function.  <a href="structhas__to__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__to__node_3_01BasicNodeType_00_01T_00_01enable__if__t_3_9is__basic__node_3_01T_01_4_1_1value_01_4_01_4.html">has_to_node&lt; BasicNodeType, T, enable_if_t&lt;!is_basic_node&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structhas__to__node.html" title="Type traits to check if T is a compatible type for BasicNodeType in terms of to_node function.">has_to_node</a> if T is not a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type.  <a href="structhas__to__node_3_01BasicNodeType_00_01T_00_01enable__if__t_3_9is__basic__node_3_01T_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__node__compatible__type__impl.html">is_node_compatible_type_impl&lt; BasicNodeType, CompatibleType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits implementation of <a class="el" href="structis__node__compatible__type.html" title="Type traits to check if CompatibleType is a compatible type for BasicNodeType.">is_node_compatible_type</a> to check if CompatibleType is a compatible type for BasicNodeType.  <a href="structis__node__compatible__type__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__node__compatible__type__impl_3_01BasicNodeType_00_01CompatibleType_00_01enable__if__t_fca3a5e6472ca43cdc6dc0e3edd0ad16.html">is_node_compatible_type_impl&lt; BasicNodeType, CompatibleType, enable_if_t&lt; conjunction&lt; is_complete_type&lt; CompatibleType &gt;, has_to_node&lt; BasicNodeType, CompatibleType &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__node__compatible__type__impl.html" title="Type traits implementation of is_node_compatible_type to check if CompatibleType is a compatible type...">is_node_compatible_type_impl</a> if CompatibleType is a complete type and is compatible for BasicNodeType.  <a href="structis__node__compatible__type__impl_3_01BasicNodeType_00_01CompatibleType_00_01enable__if__t_fca3a5e6472ca43cdc6dc0e3edd0ad16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__node__compatible__type.html">is_node_compatible_type&lt; BasicNodeType, CompatibleType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if CompatibleType is a compatible type for BasicNodeType.  <a href="structis__node__compatible__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdocument__metainfo.html">document_metainfo&lt; BasicNodeType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directives for a YAML document.  <a href="structdocument__metainfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuri__encoding.html">uri_encoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which handles URI encodings.  <a href="classuri__encoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexception.html">exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base exception class used in fkYAML library.  <a href="classexception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinvalid__encoding.html">invalid_encoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class indicating an encoding error.  <a href="classinvalid__encoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparse__error.html">parse_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class indicating an error in parsing.  <a href="classparse__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtype__error.html">type_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class indicating an invalid type conversion.  <a href="classtype__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classout__of__range.html">out_of_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class indicating an out-of-range error.  <a href="classout__of__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinvalid__tag.html">invalid_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class indicating an invalid tag.  <a href="classinvalid__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblock__scalar__header.html">block_scalar_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block scalar header information.  <a href="structblock__scalar__header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__str__view.html">basic_str_view&lt; CharT, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non owning view into constant character sequence.  <a href="classbasic__str__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classposition__tracker.html">position_tracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A position tracker of the target buffer.  <a href="classposition__tracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlexical__token.html">lexical_token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexical token information.  <a href="structlexical__token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlexical__analyzer.html">lexical_analyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which lexically analyzes YAML formatted inputs.  <a href="classlexical__analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits__base.html">conv_limits_base&lt; NumBytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure which provides limits for conversions between scalars and integers.  <a href="structconv__limits__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits__base_3_011u_01_4.html">conv_limits_base&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits__base.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits_base</a> for 1 byte integers, e.g., int8_t, uint8_t.  <a href="structconv__limits__base_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits__base_3_012u_01_4.html">conv_limits_base&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits__base.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits_base</a> for 2 byte integers, e.g., int16_t, uint16_t.  <a href="structconv__limits__base_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits__base_3_014u_01_4.html">conv_limits_base&lt; 4u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits__base.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits_base</a> for 4 byte integers, e.g., int32_t, uint32_t.  <a href="structconv__limits__base_3_014u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits__base_3_018u_01_4.html">conv_limits_base&lt; 8u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits__base.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits_base</a> for 8 byte integers, e.g., int64_t, uint64_t.  <a href="structconv__limits__base_3_018u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits.html">conv_limits&lt; NumBytes, IsSigned &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure which provides limits for conversions between scalars and integers.  <a href="structconv__limits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_011u_00_01true_01_4.html">conv_limits&lt; 1u, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 1 byte signed integers, e.g., int8_t.  <a href="structconv__limits_3_011u_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_011u_00_01false_01_4.html">conv_limits&lt; 1u, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 1 byte unsigned integers, e.g., uint8_t.  <a href="structconv__limits_3_011u_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_012u_00_01true_01_4.html">conv_limits&lt; 2u, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 2 byte signed integers, e.g., int16_t.  <a href="structconv__limits_3_012u_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_012u_00_01false_01_4.html">conv_limits&lt; 2u, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 2 byte unsigned integers, e.g., uint16_t.  <a href="structconv__limits_3_012u_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_014u_00_01true_01_4.html">conv_limits&lt; 4u, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 4 byte signed integers, e.g., int32_t.  <a href="structconv__limits_3_014u_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_014u_00_01false_01_4.html">conv_limits&lt; 4u, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 4 byte unsigned integers, e.g., uint32_t.  <a href="structconv__limits_3_014u_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_018u_00_01true_01_4.html">conv_limits&lt; 8u, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 8 byte signed integers, e.g., int64_t.  <a href="structconv__limits_3_018u_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconv__limits_3_018u_00_01false_01_4.html">conv_limits&lt; 8u, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structconv__limits.html" title="A structure which provides limits for conversions between scalars and integers.">conv_limits</a> for 8 byte unsigned integers, e.g., uint64_t.  <a href="structconv__limits_3_018u_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaml__escaper.html">yaml_escaper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscalar__scanner.html">scalar_scanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class which detects a scalar value type by scanning contents.  <a href="classscalar__scanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscalar__parser.html">scalar_parser&lt; BasicNodeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parser for YAML scalars.  <a href="classscalar__parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtag__resolver.html">tag_resolver&lt; BasicNodeType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__get__buffer__view.html">has_get_buffer_view&lt; InputAdapterType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if InputAdapterType has get_buffer_view member function.  <a href="structhas__get__buffer__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__get__buffer__view_3_01InputAdapterType_00_01enable__if__t_3_01is__detected_3_01get__bc91a701410d8d16f95992d71829ff9d2.html">has_get_buffer_view&lt; InputAdapterType, enable_if_t&lt; is_detected&lt; get_buffer_view_fn_t, InputAdapterType &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structhas__get__buffer__view.html" title="Type traits to check if InputAdapterType has get_buffer_view member function.">has_get_buffer_view</a> if InputAdapterType has get_buffer_view member function.  <a href="structhas__get__buffer__view_3_01InputAdapterType_00_01enable__if__t_3_01is__detected_3_01get__bc91a701410d8d16f95992d71829ff9d2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__input__adapter.html">is_input_adapter&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T is an input adapter type.  <a href="structis__input__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__input__adapter_3_01InputAdapterType_00_01enable__if__t_3_01has__get__buffer__view_3_011c31db6489f06cc16dd0c9d58ef9ec3b.html">is_input_adapter&lt; InputAdapterType, enable_if_t&lt; has_get_buffer_view&lt; InputAdapterType &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__input__adapter.html" title="Type traits to check if T is an input adapter type.">is_input_adapter</a> if T is an input adapter type.  <a href="structis__input__adapter_3_01InputAdapterType_00_01enable__if__t_3_01has__get__buffer__view_3_011c31db6489f06cc16dd0c9d58ef9ec3b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__contiguous__container.html">is_contiguous_container&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T is a container which has contiguous bytes.  <a href="structis__contiguous__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__contiguous__container_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">is_contiguous_container&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__contiguous__container.html" title="Type traits to check if T is a container which has contiguous bytes.">is_contiguous_container</a> if T is a std::array.  <a href="structis__contiguous__container_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__contiguous__container_3_01std_1_1basic__string_3_01CharT_00_01Traits_00_01Alloc_01_4_01_4.html">is_contiguous_container&lt; std::basic_string&lt; CharT, Traits, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__contiguous__container.html" title="Type traits to check if T is a container which has contiguous bytes.">is_contiguous_container</a> if T is a std::basic_string.  <a href="structis__contiguous__container_3_01std_1_1basic__string_3_01CharT_00_01Traits_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__contiguous__container_3_01std_1_1vector_3_01T_00_01Alloc_01_4_01_4.html">is_contiguous_container&lt; std::vector&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structis__contiguous__container.html" title="Type traits to check if T is a container which has contiguous bytes.">is_contiguous_container</a> if T is a std::vector.  <a href="structis__contiguous__container_3_01std_1_1vector_3_01T_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode__property.html">node_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__deserializer.html">basic_deserializer&lt; BasicNodeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which provides the feature of deserializing YAML documents.  <a href="classbasic__deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutf__encode__detector.html">utf_encode_detector&lt; ItrType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which detects UTF encoding type and the existence of a BOM at the beginning.  <a href="structutf__encode__detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutf__encode__detector_3_01ItrType_00_01enable__if__t_3_01is__iterator__of_3_01ItrType_00_01char_01_4_1_1value_01_4_01_4.html">utf_encode_detector&lt; ItrType, enable_if_t&lt; is_iterator_of&lt; ItrType, char &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structutf__encode__detector.html" title="A class which detects UTF encoding type and the existence of a BOM at the beginning.">utf_encode_detector</a> for char iterators.  <a href="structutf__encode__detector_3_01ItrType_00_01enable__if__t_3_01is__iterator__of_3_01ItrType_00_01char_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutf__encode__detector_3_01ItrType_00_01enable__if__t_3_01is__iterator__of_3_01ItrType_00_06ba4f011ac13ea70567a12b63dabd5a7.html">utf_encode_detector&lt; ItrType, enable_if_t&lt; is_iterator_of&lt; ItrType, char16_t &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structutf__encode__detector.html" title="A class which detects UTF encoding type and the existence of a BOM at the beginning.">utf_encode_detector</a> for char16_t iterators.  <a href="structutf__encode__detector_3_01ItrType_00_01enable__if__t_3_01is__iterator__of_3_01ItrType_00_06ba4f011ac13ea70567a12b63dabd5a7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutf__encode__detector_3_01ItrType_00_01enable__if__t_3_01is__iterator__of_3_01ItrType_00_06872e3c4ce4bb9ef79cee3f2e604d9b3.html">utf_encode_detector&lt; ItrType, enable_if_t&lt; is_iterator_of&lt; ItrType, char32_t &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structutf__encode__detector.html" title="A class which detects UTF encoding type and the existence of a BOM at the beginning.">utf_encode_detector</a> for char32_t iterators.  <a href="structutf__encode__detector_3_01ItrType_00_01enable__if__t_3_01is__iterator__of_3_01ItrType_00_06872e3c4ce4bb9ef79cee3f2e604d9b3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfile__utf__encode__detector.html">file_utf_encode_detector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which detects UTF encoding type and the existence of a BOM from the input file.  <a href="structfile__utf__encode__detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstream__utf__encode__detector.html">stream_utf_encode_detector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which detects UTF encoding type and the existence of a BOM from the input file.  <a href="structstream__utf__encode__detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiterator__input__adapter_3_01IterType_00_01enable__if__t_3_01is__iterator__of_3_01IterType_e547814bde85d8d5335ee62be88b470c.html">iterator_input_adapter&lt; IterType, enable_if_t&lt; is_iterator_of&lt; IterType, char &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input adapter for iterators of type char.  <a href="classiterator__input__adapter_3_01IterType_00_01enable__if__t_3_01is__iterator__of_3_01IterType_e547814bde85d8d5335ee62be88b470c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiterator__input__adapter_3_01IterType_00_01enable__if__t_3_01is__iterator__of_3_01IterType_5ed578c75077484cc134285068025429.html">iterator_input_adapter&lt; IterType, enable_if_t&lt; is_iterator_of&lt; IterType, char16_t &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input adapter for iterators of type char16_t.  <a href="classiterator__input__adapter_3_01IterType_00_01enable__if__t_3_01is__iterator__of_3_01IterType_5ed578c75077484cc134285068025429.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiterator__input__adapter_3_01IterType_00_01enable__if__t_3_01is__iterator__of_3_01IterType_1101104b5c49707452e3c3aaf45387f2.html">iterator_input_adapter&lt; IterType, enable_if_t&lt; is_iterator_of&lt; IterType, char32_t &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input adapter for iterators of type char32_t.  <a href="classiterator__input__adapter_3_01IterType_00_01enable__if__t_3_01is__iterator__of_3_01IterType_1101104b5c49707452e3c3aaf45387f2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfile__input__adapter.html">file_input_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input adapter for C-style file handles.  <a href="classfile__input__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstream__input__adapter.html">stream_input_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input adapter for streams.  <a href="classstream__input__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinput__adapter__factory_1_1container__input__adapter__factory.html">input_adapter_factory::container_input_adapter_factory&lt; ContainerType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory of input adapters for containers.  <a href="structinput__adapter__factory_1_1container__input__adapter__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinput__adapter__factory_1_1container__input__adapter__factory_3_01ContainerType_00_01void_057f779d6af53e29a0b3bb6585dba9ba.html">input_adapter_factory::container_input_adapter_factory&lt; ContainerType, void_t&lt; decltype(begin(std::declval&lt; ContainerType &gt;()), end(std::declval&lt; ContainerType &gt;()))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial specialization of <a class="el" href="structinput__adapter__factory_1_1container__input__adapter__factory.html" title="A factory of input adapters for containers.">container_input_adapter_factory</a> if begin()/end() are available for ContainerType.  <a href="structinput__adapter__factory_1_1container__input__adapter__factory_3_01ContainerType_00_01void_057f779d6af53e29a0b3bb6585dba9ba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiterator__traits.html">iterator_traits&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template definitions of type information used in Iterator class.  <a href="structiterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiterator__traits_3_01const_01ValueType_01_4.html">iterator_traits&lt; const ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <a class="el" href="structiterator__traits.html">iterator_traits</a> for constant value types.  <a href="structiterator__traits_3_01const_01ValueType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiterator__holder.html">iterator_holder&lt; BasicNodeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual storage for iterators internally held in iterator.  <a href="structiterator__holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiterator.html">iterator&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which holds iterators either of sequence or mapping type.  <a href="classiterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnode__ref__storage.html">node_ref_storage&lt; BasicNodeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A temporal storage for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> class objects.  <a href="classnode__ref__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__serializer.html">basic_serializer&lt; BasicNodeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic implementation of serialization feature for YAML nodes.  <a href="classbasic__serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreverse__iterator.html">reverse_iterator&lt; Iterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator adapter class that reverses the direction of a given node iterator.  <a href="classreverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcall__reserve__if__available.html">call_reserve_if_available&lt; ContainerType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for reserve() member function call switch for types which do not have reserve function.  <a href="structcall__reserve__if__available.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcall__reserve__if__available_3_01ContainerType_00_01enable__if__t_3_01detect_1_1has__reser7d5f238531e418896ba9a61d57a22f13.html">call_reserve_if_available&lt; ContainerType, enable_if_t&lt; detect::has_reserve&lt; ContainerType &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for reserve() member function call switch for types which have reserve function.  <a href="structcall__reserve__if__available_3_01ContainerType_00_01enable__if__t_3_01detect_1_1has__reser7d5f238531e418896ba9a61d57a22f13.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfrom__node__int__helper.html">from_node_int_helper&lt; BasicNodeType, IntType, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for node-to-int conversion.  <a href="structfrom__node__int__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfrom__node__int__helper_3_01BasicNodeType_00_01IntType_00_01false_01_4.html">from_node_int_helper&lt; BasicNodeType, IntType, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for node-to-int conversion if IntType is not the node's integer value type.  <a href="structfrom__node__int__helper_3_01BasicNodeType_00_01IntType_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfrom__node__float__helper.html">from_node_float_helper&lt; BasicNodeType, FloatType, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for node-to-float conversion if FloatType is the node's floating point value type.  <a href="structfrom__node__float__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfrom__node__float__helper_3_01BasicNodeType_00_01FloatType_00_01false_01_4.html">from_node_float_helper&lt; BasicNodeType, FloatType, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for node-to-float conversion if IntType is not the node's floating point value type.  <a href="structfrom__node__float__helper_3_01BasicNodeType_00_01FloatType_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfrom__node__fn.html">from_node_fn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to call from_node functions.  <a href="structfrom__node__fn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1SEQUENCE_01_4.html">external_node_constructor&lt; node_type::SEQUENCE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for sequence nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1SEQUENCE_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1MAPPING_01_4.html">external_node_constructor&lt; node_type::MAPPING &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for mapping nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1MAPPING_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1NULL__OBJECT_01_4.html">external_node_constructor&lt; node_type::NULL_OBJECT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for null nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1NULL__OBJECT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1BOOLEAN_01_4.html">external_node_constructor&lt; node_type::BOOLEAN &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for boolean scalar nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1BOOLEAN_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1INTEGER_01_4.html">external_node_constructor&lt; node_type::INTEGER &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for integer scalar nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1INTEGER_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1FLOAT_01_4.html">external_node_constructor&lt; node_type::FLOAT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for float number scalar nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1FLOAT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexternal__node__constructor_3_01node__type_1_1STRING_01_4.html">external_node_constructor&lt; node_type::STRING &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specialization of <a class="el" href="structexternal__node__constructor.html" title="The external constructor template for basic_node objects.">external_node_constructor</a> for string scalar nodes.  <a href="structexternal__node__constructor_3_01node__type_1_1STRING_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structto__node__fn.html">to_node_fn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to call to_node functions.  <a href="structto__node__fn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnode__value__converter.html">node_value_converter&lt; ValueType, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ADL friendly converter between <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> objects and native data objects.  <a href="classnode__value__converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classordered__map.html">ordered_map&lt; Key, Value, IgnoredCompare, Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal map-like container which preserves insertion order.  <a href="classordered__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__node.html">basic_node&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to store value of YAML nodes.  <a href="classbasic__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01fkyaml_1_1basic__node_3_01SequenceType_00_01MappingType_00_01BooleanType_0dc36d83ba5825af6f77c5146b18c7772.html">std::hash&lt; fkyaml::basic_node&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemake__int__seq__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemake__int__seq__impl.html">make_int_seq_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedetector__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetector__impl.html">detector_impl</a></td></tr>
<tr class="memdesc:namespacedetector__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace to implement detector type traits <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedetect"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedetect.html">detect</a></td></tr>
<tr class="memdesc:namespacedetect"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for member type detections of aliases and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutf8"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutf8.html">utf8</a></td></tr>
<tr class="memdesc:namespaceutf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which handles UTF-8 encodings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenode__attr__mask"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html">node_attr_mask</a></td></tr>
<tr class="memdesc:namespacenode__attr__mask"><td class="mdescLeft">&#160;</td><td class="mdescRight">The namespace to define bit masks for node attribute bits. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenode__attr__bits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html">node_attr_bits</a></td></tr>
<tr class="memdesc:namespacenode__attr__bits"><td class="mdescLeft">&#160;</td><td class="mdescRight">The namespace to define bits for node attributes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceinput__adapter__factory"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinput__adapter__factory.html">input_adapter_factory</a></td></tr>
<tr class="memdesc:namespaceinput__adapter__factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace to implement <a class="el" href="structinput__adapter__factory_1_1container__input__adapter__factory.html" title="A factory of input adapters for containers.">container_input_adapter_factory</a> for internal use. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceFK__YAML__NAMESPACE__BEGIN"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFK__YAML__NAMESPACE__BEGIN.html">FK_YAML_NAMESPACE_BEGIN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliterals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliterals.html">literals</a></td></tr>
<tr class="memdesc:namespaceliterals"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for user-defined literals for the fkYAML library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceliterals_1_1yaml__literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliterals_1_1yaml__literals.html">literals::yaml_literals</a></td></tr>
<tr class="memdesc:namespaceliterals_1_1yaml__literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for user-defined literals for YAML node objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac4ffd8ee169edc42f216c02f1bb38c7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ac4ffd8ee169edc42f216c02f1bb38c7b">FK_YAML_DETAIL_MACROS_DEFINE_MACROS_HPP</a></td></tr>
<tr class="separator:ac4ffd8ee169edc42f216c02f1bb38c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed32bd89469f4d21c446553b092a78e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aed32bd89469f4d21c446553b092a78e5">FK_YAML_MAJOR_VERSION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aed32bd89469f4d21c446553b092a78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb100a406a4a974beeecb7c431d2cac2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#acb100a406a4a974beeecb7c431d2cac2">FK_YAML_MINOR_VERSION</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:acb100a406a4a974beeecb7c431d2cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1473de0e2f8a700ef6521996fddf6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#afa1473de0e2f8a700ef6521996fddf6d">FK_YAML_PATCH_VERSION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:afa1473de0e2f8a700ef6521996fddf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d0af4b89c59187056fd5397750ab46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a67d0af4b89c59187056fd5397750ab46">FK_YAML_NAMESPACE_VERSION_CONCAT_IMPL</a>(major,  minor,  patch)&#160;&#160;&#160;v##major##_##minor##_##patch</td></tr>
<tr class="separator:a67d0af4b89c59187056fd5397750ab46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef760f14cd22ab6cb13697ac19aae2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#abef760f14cd22ab6cb13697ac19aae2d">FK_YAML_NAMESPACE_VERSION_CONCAT</a>(major,  minor,  patch)&#160;&#160;&#160;    <a class="el" href="node_8hpp.html#a67d0af4b89c59187056fd5397750ab46">FK_YAML_NAMESPACE_VERSION_CONCAT_IMPL</a>(major, minor, patch)</td></tr>
<tr class="separator:abef760f14cd22ab6cb13697ac19aae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099a14ffcb6ddf32b10ef261ac0da560"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a099a14ffcb6ddf32b10ef261ac0da560">FK_YAML_NAMESPACE_VERSION</a></td></tr>
<tr class="separator:a099a14ffcb6ddf32b10ef261ac0da560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185a20e9f9bea81c796ff61a9e309c00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a185a20e9f9bea81c796ff61a9e309c00">FK_YAML_NAMESPACE_BEGIN</a></td></tr>
<tr class="separator:a185a20e9f9bea81c796ff61a9e309c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea705788534510a0a7d79fd1f1fa71ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aea705788534510a0a7d79fd1f1fa71ce">FK_YAML_NAMESPACE_END</a></td></tr>
<tr class="separator:aea705788534510a0a7d79fd1f1fa71ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8205dbc6a1114becc668105819ea1b57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a></td></tr>
<tr class="separator:a8205dbc6a1114becc668105819ea1b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cc808373a7ff2e6615c65c32675dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab8cc808373a7ff2e6615c65c32675dd7">FK_YAML_DETAIL_NAMESPACE_END</a></td></tr>
<tr class="separator:ab8cc808373a7ff2e6615c65c32675dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca7bf775d1a5e4d3c8ad880d7d832e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6eca7bf775d1a5e4d3c8ad880d7d832e">FK_YAML_DETAIL_MACROS_CPP_CONFIG_MACROS_HPP</a></td></tr>
<tr class="separator:a6eca7bf775d1a5e4d3c8ad880d7d832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e76ad840169843954dcdef9f88faabe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6e76ad840169843954dcdef9f88faabe">FK_YAML_CPLUSPLUS</a>&#160;&#160;&#160;__cplusplus</td></tr>
<tr class="separator:a6e76ad840169843954dcdef9f88faabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02d604133d06d895b6be060c6a5c573"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ac02d604133d06d895b6be060c6a5c573">FK_YAML_HAS_CXX_11</a></td></tr>
<tr class="separator:ac02d604133d06d895b6be060c6a5c573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6d30daca2f760a949ea88dc5c0be7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a4f6d30daca2f760a949ea88dc5c0be7b">FK_YAML_DEPRECATED</a>(msg)</td></tr>
<tr class="separator:a4f6d30daca2f760a949ea88dc5c0be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b52f29237cf77b927dc7bf269451af7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7b52f29237cf77b927dc7bf269451af7">FK_YAML_INLINE_VAR</a></td></tr>
<tr class="separator:a7b52f29237cf77b927dc7bf269451af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed9f28c950a250f561972d09c175bed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a0ed9f28c950a250f561972d09c175bed">FK_YAML_CXX17_CONSTEXPR</a></td></tr>
<tr class="separator:a0ed9f28c950a250f561972d09c175bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f65d21181b09aefabe705743cef62d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7f65d21181b09aefabe705743cef62d7">FK_YAML_HAS_INCLUDE</a>(header)&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a7f65d21181b09aefabe705743cef62d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e750af2d337c30f39c9ad0d2dcb062"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a62e750af2d337c30f39c9ad0d2dcb062">FK_YAML_HAS_BUILTIN</a>(builtin)&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a62e750af2d337c30f39c9ad0d2dcb062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8130f3581afd8e031d89202a91de0629"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8130f3581afd8e031d89202a91de0629">FK_YAML_HAS_CPP_ATTRIBUTE</a>(attr)&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a8130f3581afd8e031d89202a91de0629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f46236f82eff7e056e6effc1611835"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a82f46236f82eff7e056e6effc1611835">FK_YAML_HAS_FEATURE</a>(feat)&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a82f46236f82eff7e056e6effc1611835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9c79e8d5ad55b8a634953a9e50f741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#abc9c79e8d5ad55b8a634953a9e50f741">FK_YAML_NO_SANITIZE</a>(...)</td></tr>
<tr class="separator:abc9c79e8d5ad55b8a634953a9e50f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b6c747235e44832a32e96165a590cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab8b6c747235e44832a32e96165a590cb">FK_YAML_HAS_TO_CHARS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ab8b6c747235e44832a32e96165a590cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e77145c4ee6f371568de3f4cfb58fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ad1e77145c4ee6f371568de3f4cfb58fb">FK_YAML_HAS_CHAR8_T</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ad1e77145c4ee6f371568de3f4cfb58fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249b991273e00aaaf85a650f27249a7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a249b991273e00aaaf85a650f27249a7a">FK_YAML_LIKELY</a>(expr)&#160;&#160;&#160;(!!(expr))</td></tr>
<tr class="separator:a249b991273e00aaaf85a650f27249a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2c2dbdfbff0a11c6f4ad6418e8c2a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aeb2c2dbdfbff0a11c6f4ad6418e8c2a4">FK_YAML_UNLIKELY</a>(expr)&#160;&#160;&#160;(!!(expr))</td></tr>
<tr class="separator:aeb2c2dbdfbff0a11c6f4ad6418e8c2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a39c368eb10dd27014ce43d8f8c1a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a07a39c368eb10dd27014ce43d8f8c1a0">FK_YAML_DETAIL_ASSERT_HPP</a></td></tr>
<tr class="separator:a07a39c368eb10dd27014ce43d8f8c1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31928ceeb5c5f5faeb6954e9c6593de5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a31928ceeb5c5f5faeb6954e9c6593de5">FK_YAML_ASSERT</a>(x)&#160;&#160;&#160;assert(x)</td></tr>
<tr class="separator:a31928ceeb5c5f5faeb6954e9c6593de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550134396f4ee560420a5da216a3c6b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a550134396f4ee560420a5da216a3c6b7">FK_YAML_DETAIL_DOCUMENT_METAINFO_HPP</a></td></tr>
<tr class="separator:a550134396f4ee560420a5da216a3c6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48827bac72ca15afcf930e9c7df98d4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a48827bac72ca15afcf930e9c7df98d4d">FK_YAML_DETAIL_META_NODE_TRAITS_HPP</a></td></tr>
<tr class="separator:a48827bac72ca15afcf930e9c7df98d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e0e604d41150b1e67ca46892712dc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a08e0e604d41150b1e67ca46892712dc1">FK_YAML_DETAIL_META_DETECT_HPP</a></td></tr>
<tr class="separator:a08e0e604d41150b1e67ca46892712dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8801f8388f1fe5747182e8b93f5884d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#af8801f8388f1fe5747182e8b93f5884d">FK_YAML_DETAIL_META_STL_SUPPLEMENT_HPP</a></td></tr>
<tr class="separator:af8801f8388f1fe5747182e8b93f5884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087aea18ba799c7628d26120ffe4fd5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a087aea18ba799c7628d26120ffe4fd5b">FK_YAML_DETAIL_META_TYPE_TRAITS_HPP</a></td></tr>
<tr class="separator:a087aea18ba799c7628d26120ffe4fd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5496e0cab9870aae8817553992dd331f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5496e0cab9870aae8817553992dd331f">FK_YAML_FKYAML_FWD_HPP</a></td></tr>
<tr class="separator:a5496e0cab9870aae8817553992dd331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ba7a72bef1bb2ed457b35c954eb59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8f7ba7a72bef1bb2ed457b35c954eb59">FK_YAML_YAML_VERSION_TYPE_HPP</a></td></tr>
<tr class="separator:a8f7ba7a72bef1bb2ed457b35c954eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7dc7dc73c20b60450c5e45c0d095fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aac7dc7dc73c20b60450c5e45c0d095fe">FK_YAML_DETAIL_INPUT_DESERIALIZER_HPP</a></td></tr>
<tr class="separator:aac7dc7dc73c20b60450c5e45c0d095fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee288e8b7b5d792eb26019e7028972f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2ee288e8b7b5d792eb26019e7028972f">FK_YAML_DETAIL_INPUT_LEXICAL_ANALYZER_HPP</a></td></tr>
<tr class="separator:a2ee288e8b7b5d792eb26019e7028972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6128f597b980ad8c14791716b16f6905"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6128f597b980ad8c14791716b16f6905">FK_YAML_DETAIL_ENCODINGS_URI_ENCODING_HPP</a></td></tr>
<tr class="separator:a6128f597b980ad8c14791716b16f6905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f616bba37f166a685652c7cb435367"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a30f616bba37f166a685652c7cb435367">FK_YAML_DETAIL_ENCODINGS_UTF_ENCODINGS_HPP</a></td></tr>
<tr class="separator:a30f616bba37f166a685652c7cb435367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a92fe80f3698335a9fe2691307053e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ad2a92fe80f3698335a9fe2691307053e">FK_YAML_EXCEPTION_HPP</a></td></tr>
<tr class="separator:ad2a92fe80f3698335a9fe2691307053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e070a7e65cc31352a463f6f867ecb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a12e070a7e65cc31352a463f6f867ecb4">FK_YAML_DETAIL_STRING_FORMATTER_HPP</a></td></tr>
<tr class="separator:a12e070a7e65cc31352a463f6f867ecb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe061b5111fc7195ef17d9edca4f5b84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#afe061b5111fc7195ef17d9edca4f5b84">FK_YAML_DETAIL_TYPES_NODE_T_HPP</a></td></tr>
<tr class="separator:afe061b5111fc7195ef17d9edca4f5b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafd9fee79fab98bf86a0cffb506ed6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aeafd9fee79fab98bf86a0cffb506ed6a">FK_YAML_NODE_TYPE_HPP</a></td></tr>
<tr class="separator:aeafd9fee79fab98bf86a0cffb506ed6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517cfa098a14dbb480f7daa8992f70a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a517cfa098a14dbb480f7daa8992f70a5">FK_YAML_DETAIL_INPUT_BLOCK_SCALAR_HEADER_HPP</a></td></tr>
<tr class="separator:a517cfa098a14dbb480f7daa8992f70a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fc1005dcc5f39e8de8c29e1ad93aa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#af6fc1005dcc5f39e8de8c29e1ad93aa4">FK_YAML_DETAIL_INPUT_POSITION_TRACKER_HPP</a></td></tr>
<tr class="separator:af6fc1005dcc5f39e8de8c29e1ad93aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521ec30a3d8b7ba2d97fbb32ed571a4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a521ec30a3d8b7ba2d97fbb32ed571a4b">FK_YAML_DETAIL_STR_VIEW_HPP</a></td></tr>
<tr class="separator:a521ec30a3d8b7ba2d97fbb32ed571a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b5f982720d59454a6c85123b7a7597"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ae5b5f982720d59454a6c85123b7a7597">FK_YAML_DETAIL_TYPES_LEXICAL_TOKEN_T_HPP</a></td></tr>
<tr class="separator:ae5b5f982720d59454a6c85123b7a7597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231e5620702ff02f316d9ab7e0c4237"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a9231e5620702ff02f316d9ab7e0c4237">FK_YAML_DETAIL_INPUT_SCALAR_PARSER_HPP</a></td></tr>
<tr class="separator:a9231e5620702ff02f316d9ab7e0c4237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315ca62cbd45547de6f2cad2605ed96b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a315ca62cbd45547de6f2cad2605ed96b">FK_YAML_CONVERSIONS_SCALAR_CONV_HPP</a></td></tr>
<tr class="separator:a315ca62cbd45547de6f2cad2605ed96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce5c06e4036c88b6f2bee7a659af147"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5ce5c06e4036c88b6f2bee7a659af147">FK_YAML_DETAIL_ENCODINGS_YAML_ESCAPER_HPP</a></td></tr>
<tr class="separator:a5ce5c06e4036c88b6f2bee7a659af147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2229ba9eb449979c3469671ba139ba5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2229ba9eb449979c3469671ba139ba5a">FK_YAML_DETAIL_INPUT_SCALAR_SCANNER_HPP</a></td></tr>
<tr class="separator:a2229ba9eb449979c3469671ba139ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7eaf3b7c95ae119e3ff84b92406f6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ace7eaf3b7c95ae119e3ff84b92406f6f">FK_YAML_DETAIL_INPUT_TAG_T_HPP</a></td></tr>
<tr class="separator:ace7eaf3b7c95ae119e3ff84b92406f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494fc1ebde74204108a8ca6a50049634"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a494fc1ebde74204108a8ca6a50049634">FK_YAML_DETAIL_INPUT_TAG_RESOLVER_HPP</a></td></tr>
<tr class="separator:a494fc1ebde74204108a8ca6a50049634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f87ef55820cf1915d8092b5ad2ec182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a0f87ef55820cf1915d8092b5ad2ec182">FK_YAML_DETAIL_META_INPUT_ADAPTER_TRAITS_HPP</a></td></tr>
<tr class="separator:a0f87ef55820cf1915d8092b5ad2ec182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd2f459bbe8d251d129a7e90d80b39f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2cd2f459bbe8d251d129a7e90d80b39f">FK_YAML_DETAIL_NODE_ATTRS_HPP</a></td></tr>
<tr class="separator:a2cd2f459bbe8d251d129a7e90d80b39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40079b7d8557ed5715105f51e0fc79bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a40079b7d8557ed5715105f51e0fc79bf">FK_YAML_DETAIL_NODE_PROPERTY_HPP</a></td></tr>
<tr class="separator:a40079b7d8557ed5715105f51e0fc79bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e898263e01addd077817a0dee60f444"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a0e898263e01addd077817a0dee60f444">FK_YAML_DETAIL_INPUT_INPUT_ADAPTER_HPP</a></td></tr>
<tr class="separator:a0e898263e01addd077817a0dee60f444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6678411ce2f413d10ab939fca4950e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8c6678411ce2f413d10ab939fca4950e">FK_YAML_DETAIL_ENCODINGS_UTF_ENCODE_DETECTOR_HPP</a></td></tr>
<tr class="separator:a8c6678411ce2f413d10ab939fca4950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf722435965e0efbb23fd6e9d75806a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#afbf722435965e0efbb23fd6e9d75806a">FK_YAML_DETAIL_ENCODINGS_UTF_ENCODE_T_HPP</a></td></tr>
<tr class="separator:afbf722435965e0efbb23fd6e9d75806a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9575789661c871a7cf91ad56b0ea4778"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a9575789661c871a7cf91ad56b0ea4778">FK_YAML_DETAIL_ITERATOR_HPP</a></td></tr>
<tr class="separator:a9575789661c871a7cf91ad56b0ea4778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb54d961ccf200d835b1aa663c2eed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#acfcb54d961ccf200d835b1aa663c2eed">FK_YAML_DETAIL_NODE_REF_STORAGE_HPP</a></td></tr>
<tr class="separator:acfcb54d961ccf200d835b1aa663c2eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccb6e99c83db2575b974ed5629d64d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8ccb6e99c83db2575b974ed5629d64d1">FK_YAML_DETAIL_OUTPUT_SERIALIZER_HPP</a></td></tr>
<tr class="separator:a8ccb6e99c83db2575b974ed5629d64d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb418b84d5dfc8c760da80ac4acbe17a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aeb418b84d5dfc8c760da80ac4acbe17a">FK_YAML_DETAIL_CONVERSIONS_TO_STRING_HPP</a></td></tr>
<tr class="separator:aeb418b84d5dfc8c760da80ac4acbe17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8bb7ba3a320d8ac631b02acf395d94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6c8bb7ba3a320d8ac631b02acf395d94">FK_YAML_DETAIL_REVERSE_ITERATOR_HPP</a></td></tr>
<tr class="separator:a6c8bb7ba3a320d8ac631b02acf395d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae638cb73c78e8fd3696e86a5e7304d98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ae638cb73c78e8fd3696e86a5e7304d98">FK_YAML_DETAIL_TYPES_YAML_VERSION_T_HPP</a></td></tr>
<tr class="separator:ae638cb73c78e8fd3696e86a5e7304d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d63ae2fec31f8307e150311aa07be01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5d63ae2fec31f8307e150311aa07be01">FK_YAML_NODE_VALUE_CONVERTER_HPP</a></td></tr>
<tr class="separator:a5d63ae2fec31f8307e150311aa07be01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fb059a0fa6820c9e6e9d763361a811"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a73fb059a0fa6820c9e6e9d763361a811">FK_YAML_DETAIL_CONVERSIONS_FROM_NODE_HPP</a></td></tr>
<tr class="separator:a73fb059a0fa6820c9e6e9d763361a811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ec05a7fc82a2428429df8c5271aa8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a903ec05a7fc82a2428429df8c5271aa8">FK_YAML_DETAIL_CONVERSIONS_TO_NODE_HPP</a></td></tr>
<tr class="separator:a903ec05a7fc82a2428429df8c5271aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1af9ddb0c5a60ede41fe1a88932704"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#abd1af9ddb0c5a60ede41fe1a88932704">FK_YAML_ORDERED_MAP_HPP</a></td></tr>
<tr class="separator:abd1af9ddb0c5a60ede41fe1a88932704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4d53001e66630d08082e94939d47d8d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d53001e66630d08082e94939d47d8d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a4d53001e66630d08082e94939d47d8d7">add_pointer_t</a> = typename std::add_pointer&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4d53001e66630d08082e94939d47d8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for std::add_pointer::type with C++11.  <a href="node_8hpp.html#a4d53001e66630d08082e94939d47d8d7">More...</a><br /></td></tr>
<tr class="separator:a4d53001e66630d08082e94939d47d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686f4990569708f40dfde235b6c3b11"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T  = void&gt; </td></tr>
<tr class="memitem:a7686f4990569708f40dfde235b6c3b11"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">enable_if_t</a> = typename std::enable_if&lt; Condition, T &gt;::type</td></tr>
<tr class="memdesc:a7686f4990569708f40dfde235b6c3b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for std::enable_if::type with C++11.  <a href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">More...</a><br /></td></tr>
<tr class="separator:a7686f4990569708f40dfde235b6c3b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dc8767e0b0b9b6022f61cb5b52278f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92dc8767e0b0b9b6022f61cb5b52278f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a92dc8767e0b0b9b6022f61cb5b52278f">remove_cv_t</a> = typename std::remove_cv&lt; T &gt;::type</td></tr>
<tr class="memdesc:a92dc8767e0b0b9b6022f61cb5b52278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for std::remove_cv::type with C++11.  <a href="node_8hpp.html#a92dc8767e0b0b9b6022f61cb5b52278f">More...</a><br /></td></tr>
<tr class="separator:a92dc8767e0b0b9b6022f61cb5b52278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d01d5cd2bed140c973e49eaced167"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add6d01d5cd2bed140c973e49eaced167"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#add6d01d5cd2bed140c973e49eaced167">remove_pointer_t</a> = typename std::remove_pointer&lt; T &gt;::type</td></tr>
<tr class="memdesc:add6d01d5cd2bed140c973e49eaced167"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for std::remove_pointer::type with C++11.  <a href="node_8hpp.html#add6d01d5cd2bed140c973e49eaced167">More...</a><br /></td></tr>
<tr class="separator:add6d01d5cd2bed140c973e49eaced167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08cea569e6926ac8d7d74dd7178b5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a08cea569e6926ac8d7d74dd7178b5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3a08cea569e6926ac8d7d74dd7178b5f">remove_reference_t</a> = typename std::remove_reference&lt; T &gt;::type</td></tr>
<tr class="memdesc:a3a08cea569e6926ac8d7d74dd7178b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for std::remove_reference::type with C++11.  <a href="node_8hpp.html#a3a08cea569e6926ac8d7d74dd7178b5f">More...</a><br /></td></tr>
<tr class="separator:a3a08cea569e6926ac8d7d74dd7178b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f3ba12ebeca36c1c8225bdc6359256"><td class="memTemplParams" colspan="2">template&lt;typename T , T Num&gt; </td></tr>
<tr class="memitem:a75f3ba12ebeca36c1c8225bdc6359256"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a75f3ba12ebeca36c1c8225bdc6359256">make_integer_sequence</a> = typename <a class="el" href="structmake__int__seq__impl_1_1generator.html">make_int_seq_impl::generator</a>&lt; T, Num &gt;::type</td></tr>
<tr class="separator:a75f3ba12ebeca36c1c8225bdc6359256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961d746437c4b43a508e8841f4c5c6c4"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Idx&gt; </td></tr>
<tr class="memitem:a961d746437c4b43a508e8841f4c5c6c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a961d746437c4b43a508e8841f4c5c6c4">index_sequence</a> = <a class="el" href="structinteger__sequence.html">integer_sequence</a>&lt; std::size_t, Idx... &gt;</td></tr>
<tr class="separator:a961d746437c4b43a508e8841f4c5c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656800682289b17d905c9d5c4826b798"><td class="memTemplParams" colspan="2">template&lt;std::size_t Num&gt; </td></tr>
<tr class="memitem:a656800682289b17d905c9d5c4826b798"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a656800682289b17d905c9d5c4826b798">make_index_sequence</a> = <a class="el" href="node_8hpp.html#a75f3ba12ebeca36c1c8225bdc6359256">make_integer_sequence</a>&lt; std::size_t, Num &gt;</td></tr>
<tr class="separator:a656800682289b17d905c9d5c4826b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b762cc05183be4d9e4f4f271add4c1e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a7b762cc05183be4d9e4f4f271add4c1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7b762cc05183be4d9e4f4f271add4c1e">index_sequence_for</a> = <a class="el" href="node_8hpp.html#a656800682289b17d905c9d5c4826b798">make_index_sequence</a>&lt; sizeof...(Types)&gt;</td></tr>
<tr class="separator:a7b762cc05183be4d9e4f4f271add4c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cc2298319894aeb38111302940516c"><td class="memTemplParams" colspan="2">template&lt;bool Val&gt; </td></tr>
<tr class="memitem:a54cc2298319894aeb38111302940516c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a54cc2298319894aeb38111302940516c">bool_constant</a> = std::integral_constant&lt; bool, Val &gt;</td></tr>
<tr class="memdesc:a54cc2298319894aeb38111302940516c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::bool_constant with C++11/C++14.  <a href="node_8hpp.html#a54cc2298319894aeb38111302940516c">More...</a><br /></td></tr>
<tr class="separator:a54cc2298319894aeb38111302940516c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2b02141ca4d395e98e45d91cc38c38"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aea2b02141ca4d395e98e45d91cc38c38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aea2b02141ca4d395e98e45d91cc38c38">void_t</a> = typename <a class="el" href="structmake__void.html">make_void</a>&lt; Types... &gt;::type</td></tr>
<tr class="memdesc:aea2b02141ca4d395e98e45d91cc38c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::void_t with C++11/C++14.  <a href="node_8hpp.html#aea2b02141ca4d395e98e45d91cc38c38">More...</a><br /></td></tr>
<tr class="separator:aea2b02141ca4d395e98e45d91cc38c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51409636427db2734c1d4d0cbd00dd42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51409636427db2734c1d4d0cbd00dd42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a51409636427db2734c1d4d0cbd00dd42">remove_cvref_t</a> = typename std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:a51409636427db2734c1d4d0cbd00dd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation to use std::remove_cvref_t with C++11/C++14/C++17.  <a href="node_8hpp.html#a51409636427db2734c1d4d0cbd00dd42">More...</a><br /></td></tr>
<tr class="separator:a51409636427db2734c1d4d0cbd00dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59350837add49f0168ac942d20bbd3b6"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a59350837add49f0168ac942d20bbd3b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a> = <a class="el" href="structdetector__impl_1_1detector.html">detector_impl::detector</a>&lt; <a class="el" href="structnonesuch.html">nonesuch</a>, void, Op, Args... &gt;</td></tr>
<tr class="memdesc:a59350837add49f0168ac942d20bbd3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to detect Op operation with Args argument types.  <a href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">More...</a><br /></td></tr>
<tr class="separator:a59350837add49f0168ac942d20bbd3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539f233efc15f8dee586f0ebc829bdf4"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a539f233efc15f8dee586f0ebc829bdf4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a539f233efc15f8dee586f0ebc829bdf4">detected_t</a> = typename <a class="el" href="structdetector__impl_1_1detector.html">detector_impl::detector</a>&lt; <a class="el" href="structnonesuch.html">nonesuch</a>, void, Op, Args... &gt;::type</td></tr>
<tr class="memdesc:a539f233efc15f8dee586f0ebc829bdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to represent a detected type.  <a href="node_8hpp.html#a539f233efc15f8dee586f0ebc829bdf4">More...</a><br /></td></tr>
<tr class="separator:a539f233efc15f8dee586f0ebc829bdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54efded7d5471a1b8d88f5c2422a767e"><td class="memTemplParams" colspan="2">template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a54efded7d5471a1b8d88f5c2422a767e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a54efded7d5471a1b8d88f5c2422a767e">is_detected_exact</a> = std::is_same&lt; Expected, <a class="el" href="node_8hpp.html#a539f233efc15f8dee586f0ebc829bdf4">detected_t</a>&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="memdesc:a54efded7d5471a1b8d88f5c2422a767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if Expected and a detected type are exactly the same.  <a href="node_8hpp.html#a54efded7d5471a1b8d88f5c2422a767e">More...</a><br /></td></tr>
<tr class="separator:a54efded7d5471a1b8d88f5c2422a767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916febbb71993350e785709677ff36fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a916febbb71993350e785709677ff36fe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a916febbb71993350e785709677ff36fe">detect::iterator_t</a> = typename T::iterator</td></tr>
<tr class="memdesc:a916febbb71993350e785709677ff36fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>iterator</code> member type.  <a href="namespacedetect.html#a916febbb71993350e785709677ff36fe">More...</a><br /></td></tr>
<tr class="separator:a916febbb71993350e785709677ff36fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f8749cb70864bf1a1e2f30c96f3b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a452f8749cb70864bf1a1e2f30c96f3b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a452f8749cb70864bf1a1e2f30c96f3b3">detect::key_type_t</a> = typename T::key_type</td></tr>
<tr class="memdesc:a452f8749cb70864bf1a1e2f30c96f3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>key_type</code> member type.  <a href="namespacedetect.html#a452f8749cb70864bf1a1e2f30c96f3b3">More...</a><br /></td></tr>
<tr class="separator:a452f8749cb70864bf1a1e2f30c96f3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d79eea162ff68ea33186675148ff54d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d79eea162ff68ea33186675148ff54d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a5d79eea162ff68ea33186675148ff54d">detect::mapped_type_t</a> = typename T::mapped_type</td></tr>
<tr class="memdesc:a5d79eea162ff68ea33186675148ff54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>mapped_type</code> member type.  <a href="namespacedetect.html#a5d79eea162ff68ea33186675148ff54d">More...</a><br /></td></tr>
<tr class="separator:a5d79eea162ff68ea33186675148ff54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcb8a85674e25ebbba674b15e8e1401"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fcb8a85674e25ebbba674b15e8e1401"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a9fcb8a85674e25ebbba674b15e8e1401">detect::value_type_t</a> = typename T::value_type</td></tr>
<tr class="memdesc:a9fcb8a85674e25ebbba674b15e8e1401"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>value_type</code> member type.  <a href="namespacedetect.html#a9fcb8a85674e25ebbba674b15e8e1401">More...</a><br /></td></tr>
<tr class="separator:a9fcb8a85674e25ebbba674b15e8e1401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d36abf4319ab9a62da000fdbad0ae1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9d36abf4319ab9a62da000fdbad0ae1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#ad9d36abf4319ab9a62da000fdbad0ae1">detect::difference_type_t</a> = typename T::difference_type</td></tr>
<tr class="memdesc:ad9d36abf4319ab9a62da000fdbad0ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>difference_type</code> member type.  <a href="namespacedetect.html#ad9d36abf4319ab9a62da000fdbad0ae1">More...</a><br /></td></tr>
<tr class="separator:ad9d36abf4319ab9a62da000fdbad0ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b684fbd993ec69308048d334ec437ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b684fbd993ec69308048d334ec437ba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a4b684fbd993ec69308048d334ec437ba">detect::pointer_t</a> = typename T::pointer</td></tr>
<tr class="memdesc:a4b684fbd993ec69308048d334ec437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>pointer</code> member type.  <a href="namespacedetect.html#a4b684fbd993ec69308048d334ec437ba">More...</a><br /></td></tr>
<tr class="separator:a4b684fbd993ec69308048d334ec437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08f2d57a16f860b9770454203e9d814"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab08f2d57a16f860b9770454203e9d814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#ab08f2d57a16f860b9770454203e9d814">detect::reference_t</a> = typename T::reference</td></tr>
<tr class="memdesc:ab08f2d57a16f860b9770454203e9d814"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>reference</code> member type.  <a href="namespacedetect.html#ab08f2d57a16f860b9770454203e9d814">More...</a><br /></td></tr>
<tr class="separator:ab08f2d57a16f860b9770454203e9d814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae8b52156ca3c0ee0f848beeacb8e93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ae8b52156ca3c0ee0f848beeacb8e93"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a4ae8b52156ca3c0ee0f848beeacb8e93">detect::iterator_category_t</a> = typename T::iterator_category</td></tr>
<tr class="memdesc:a4ae8b52156ca3c0ee0f848beeacb8e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>iterator_category</code> member type.  <a href="namespacedetect.html#a4ae8b52156ca3c0ee0f848beeacb8e93">More...</a><br /></td></tr>
<tr class="separator:a4ae8b52156ca3c0ee0f848beeacb8e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969484ff7331d8fcf4ba41b91f2a52bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a969484ff7331d8fcf4ba41b91f2a52bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a969484ff7331d8fcf4ba41b91f2a52bb">detect::container_type_t</a> = typename T::container_type</td></tr>
<tr class="memdesc:a969484ff7331d8fcf4ba41b91f2a52bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents <code>container_type</code> member type.  <a href="namespacedetect.html#a969484ff7331d8fcf4ba41b91f2a52bb">More...</a><br /></td></tr>
<tr class="separator:a969484ff7331d8fcf4ba41b91f2a52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6947ddca34663e588a6edefe7428f59b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a6947ddca34663e588a6edefe7428f59b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a6947ddca34663e588a6edefe7428f59b">detect::emplace_fn_t</a> = decltype(std::declval&lt; T &gt;().emplace(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a6947ddca34663e588a6edefe7428f59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents emplace member function.  <a href="namespacedetect.html#a6947ddca34663e588a6edefe7428f59b">More...</a><br /></td></tr>
<tr class="separator:a6947ddca34663e588a6edefe7428f59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092cb6583f1125c658d9371911b645a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a092cb6583f1125c658d9371911b645a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a092cb6583f1125c658d9371911b645a4">detect::reserve_fn_t</a> = decltype(std::declval&lt; T &gt;().reserve(std::declval&lt; typename T::size_type &gt;()))</td></tr>
<tr class="memdesc:a092cb6583f1125c658d9371911b645a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type which represents reserve member function.  <a href="namespacedetect.html#a092cb6583f1125c658d9371911b645a4">More...</a><br /></td></tr>
<tr class="separator:a092cb6583f1125c658d9371911b645a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed08d4544a75e5712c1aa976a2e8c2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afed08d4544a75e5712c1aa976a2e8c2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#afed08d4544a75e5712c1aa976a2e8c2e">detect::has_iterator</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; <a class="el" href="node_8hpp.html#acb8c614d98ee86254fb432b2f82e7ebb">iterator_t</a>, T &gt;</td></tr>
<tr class="memdesc:afed08d4544a75e5712c1aa976a2e8c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has <code>iterator</code> member type.  <a href="namespacedetect.html#afed08d4544a75e5712c1aa976a2e8c2e">More...</a><br /></td></tr>
<tr class="separator:afed08d4544a75e5712c1aa976a2e8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3a084fde4974f3064ce9e9f0e1665"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affb3a084fde4974f3064ce9e9f0e1665"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#affb3a084fde4974f3064ce9e9f0e1665">detect::has_key_type</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; key_type_t, T &gt;</td></tr>
<tr class="memdesc:affb3a084fde4974f3064ce9e9f0e1665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has <code>key_type</code> member type.  <a href="namespacedetect.html#affb3a084fde4974f3064ce9e9f0e1665">More...</a><br /></td></tr>
<tr class="separator:affb3a084fde4974f3064ce9e9f0e1665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5db101970db1faec2887b4857f89b54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5db101970db1faec2887b4857f89b54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#ab5db101970db1faec2887b4857f89b54">detect::has_mapped_type</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; mapped_type_t, T &gt;</td></tr>
<tr class="memdesc:ab5db101970db1faec2887b4857f89b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has <code>mapped_type</code> member type.  <a href="namespacedetect.html#ab5db101970db1faec2887b4857f89b54">More...</a><br /></td></tr>
<tr class="separator:ab5db101970db1faec2887b4857f89b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5773069cbdb23777e6310c7d510445f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5773069cbdb23777e6310c7d510445f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a5773069cbdb23777e6310c7d510445f9">detect::has_value_type</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; value_type_t, T &gt;</td></tr>
<tr class="memdesc:a5773069cbdb23777e6310c7d510445f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has <code>value_type</code> member type.  <a href="namespacedetect.html#a5773069cbdb23777e6310c7d510445f9">More...</a><br /></td></tr>
<tr class="separator:a5773069cbdb23777e6310c7d510445f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb7e3d7d6761807e13d9ba9df2bf73f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfb7e3d7d6761807e13d9ba9df2bf73f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#acfb7e3d7d6761807e13d9ba9df2bf73f">detect::has_container_type</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; container_type_t, T &gt;</td></tr>
<tr class="memdesc:acfb7e3d7d6761807e13d9ba9df2bf73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has <code>container_type</code> member type.  <a href="namespacedetect.html#acfb7e3d7d6761807e13d9ba9df2bf73f">More...</a><br /></td></tr>
<tr class="separator:acfb7e3d7d6761807e13d9ba9df2bf73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b517cb94fb1dd9c473ffecede296be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a49b517cb94fb1dd9c473ffecede296be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a49b517cb94fb1dd9c473ffecede296be">detect::has_emplace</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; emplace_fn_t, T, Args... &gt;</td></tr>
<tr class="memdesc:a49b517cb94fb1dd9c473ffecede296be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has emplace member function.  <a href="namespacedetect.html#a49b517cb94fb1dd9c473ffecede296be">More...</a><br /></td></tr>
<tr class="separator:a49b517cb94fb1dd9c473ffecede296be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3903653a89ab616855a1e159d5df405d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3903653a89ab616855a1e159d5df405d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedetect.html#a3903653a89ab616855a1e159d5df405d">detect::has_reserve</a> = <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a>&lt; reserve_fn_t, T &gt;</td></tr>
<tr class="memdesc:a3903653a89ab616855a1e159d5df405d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if T has reserve member function.  <a href="namespacedetect.html#a3903653a89ab616855a1e159d5df405d">More...</a><br /></td></tr>
<tr class="separator:a3903653a89ab616855a1e159d5df405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa20eda759366a68f17a54f537ae8047"><td class="memTemplParams" colspan="2">template&lt;typename Comparator , typename ObjectKeyType , typename KeyType &gt; </td></tr>
<tr class="memitem:aaa20eda759366a68f17a54f537ae8047"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aaa20eda759366a68f17a54f537ae8047">is_usable_as_key_type</a> = typename std::conditional&lt; <a class="el" href="structis__comparable.html">is_comparable</a>&lt; Comparator, ObjectKeyType, KeyType &gt;::value, std::true_type, std::false_type &gt;::type</td></tr>
<tr class="memdesc:aaa20eda759366a68f17a54f537ae8047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if KeyType can be used as key type.  <a href="node_8hpp.html#aaa20eda759366a68f17a54f537ae8047">More...</a><br /></td></tr>
<tr class="separator:aaa20eda759366a68f17a54f537ae8047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2004f373c1cccbd777a968a2da335c8"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aa2004f373c1cccbd777a968a2da335c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aa2004f373c1cccbd777a968a2da335c8">is_all_signed</a> = <a class="el" href="structconjunction.html">conjunction</a>&lt; std::is_signed&lt; Types &gt;... &gt;</td></tr>
<tr class="memdesc:aa2004f373c1cccbd777a968a2da335c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if Types are all signed arithmetic types.  <a href="node_8hpp.html#aa2004f373c1cccbd777a968a2da335c8">More...</a><br /></td></tr>
<tr class="separator:aa2004f373c1cccbd777a968a2da335c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda646dae91776c1a743caa0997d3453"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aeda646dae91776c1a743caa0997d3453"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aeda646dae91776c1a743caa0997d3453">is_all_unsigned</a> = <a class="el" href="structconjunction.html">conjunction</a>&lt; std::is_unsigned&lt; Types &gt;... &gt;</td></tr>
<tr class="memdesc:aeda646dae91776c1a743caa0997d3453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits to check if Types are all unsigned arithmetic types.  <a href="node_8hpp.html#aeda646dae91776c1a743caa0997d3453">More...</a><br /></td></tr>
<tr class="separator:aeda646dae91776c1a743caa0997d3453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790578ac5b9452db0206e4caa96ea99d"><td class="memTemplParams" colspan="2">template&lt;typename ItrType , typename T &gt; </td></tr>
<tr class="memitem:a790578ac5b9452db0206e4caa96ea99d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a790578ac5b9452db0206e4caa96ea99d">is_iterator_of</a> = std::is_same&lt; <a class="el" href="node_8hpp.html#a92dc8767e0b0b9b6022f61cb5b52278f">remove_cv_t</a>&lt; typename std::iterator_traits&lt; ItrType &gt;::value_type &gt;, T &gt;</td></tr>
<tr class="memdesc:a790578ac5b9452db0206e4caa96ea99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility alias to test if the value type of <code>ItrType</code> is <code>T</code>.  <a href="node_8hpp.html#a790578ac5b9452db0206e4caa96ea99d">More...</a><br /></td></tr>
<tr class="separator:a790578ac5b9452db0206e4caa96ea99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ae1331bcc376fb9bd8c6d3c64416ca"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a83ae1331bcc376fb9bd8c6d3c64416ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a83ae1331bcc376fb9bd8c6d3c64416ca">head_type</a> = typename <a class="el" href="structget__head__type.html">get_head_type</a>&lt; Types... &gt;::type</td></tr>
<tr class="memdesc:a83ae1331bcc376fb9bd8c6d3c64416ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template to retrieve the first type in variadic template arguments.  <a href="node_8hpp.html#a83ae1331bcc376fb9bd8c6d3c64416ca">More...</a><br /></td></tr>
<tr class="separator:a83ae1331bcc376fb9bd8c6d3c64416ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537684263bad4bb413d1fd068cd09609"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a537684263bad4bb413d1fd068cd09609">node</a> = <a class="el" href="classbasic__node.html">basic_node</a>&lt;&gt;</td></tr>
<tr class="memdesc:a537684263bad4bb413d1fd068cd09609"><td class="mdescLeft">&#160;</td><td class="mdescRight">default YAML node value container.  <a href="node_8hpp.html#a537684263bad4bb413d1fd068cd09609">More...</a><br /></td></tr>
<tr class="separator:a537684263bad4bb413d1fd068cd09609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48edf3cb86a41f7cbe08cbf7a59c33f2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a48edf3cb86a41f7cbe08cbf7a59c33f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a48edf3cb86a41f7cbe08cbf7a59c33f2">from_node_function_t</a> = decltype(<a class="el" href="node_8hpp.html#a0cb5527cd21e5e57efdcbcb6d5de5750">T::from_node</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a48edf3cb86a41f7cbe08cbf7a59c33f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type represent from_node function.  <a href="node_8hpp.html#a48edf3cb86a41f7cbe08cbf7a59c33f2">More...</a><br /></td></tr>
<tr class="separator:a48edf3cb86a41f7cbe08cbf7a59c33f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a047506a991ff456242540ea71f0f2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ae1a047506a991ff456242540ea71f0f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ae1a047506a991ff456242540ea71f0f2">to_node_function_t</a> = decltype(<a class="el" href="node_8hpp.html#a1f7ae98d52265316a5c797c06b0cf994">T::to_node</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:ae1a047506a991ff456242540ea71f0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type which represent to_node function.  <a href="node_8hpp.html#ae1a047506a991ff456242540ea71f0f2">More...</a><br /></td></tr>
<tr class="separator:ae1a047506a991ff456242540ea71f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c4ce5b7369228779637c6bc99e548d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a16c4ce5b7369228779637c6bc99e548d">str_view</a> = <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a16c4ce5b7369228779637c6bc99e548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">view into <code>char</code> sequence.  <a href="node_8hpp.html#a16c4ce5b7369228779637c6bc99e548d">More...</a><br /></td></tr>
<tr class="separator:a16c4ce5b7369228779637c6bc99e548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50d00ebb4915d58c6d7f17be493431"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aff50d00ebb4915d58c6d7f17be493431">u16str_view</a> = <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:aff50d00ebb4915d58c6d7f17be493431"><td class="mdescLeft">&#160;</td><td class="mdescRight">view into <code>char16_t</code> sequence.  <a href="node_8hpp.html#aff50d00ebb4915d58c6d7f17be493431">More...</a><br /></td></tr>
<tr class="separator:aff50d00ebb4915d58c6d7f17be493431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62f61f437c1cefdc65e3edf7a8c24a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#af62f61f437c1cefdc65e3edf7a8c24a9">u32str_view</a> = <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:af62f61f437c1cefdc65e3edf7a8c24a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">view into <code>char32_t</code> sequence.  <a href="node_8hpp.html#af62f61f437c1cefdc65e3edf7a8c24a9">More...</a><br /></td></tr>
<tr class="separator:af62f61f437c1cefdc65e3edf7a8c24a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b738785a0eb6b59b96ad9c371db5680"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b738785a0eb6b59b96ad9c371db5680"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2b738785a0eb6b59b96ad9c371db5680">get_buffer_view_fn_t</a> = decltype(std::declval&lt; T &gt;().get_buffer_view())</td></tr>
<tr class="memdesc:a2b738785a0eb6b59b96ad9c371db5680"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type which represents get_buffer_view function.  <a href="node_8hpp.html#a2b738785a0eb6b59b96ad9c371db5680">More...</a><br /></td></tr>
<tr class="separator:a2b738785a0eb6b59b96ad9c371db5680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6227d2a40d02dbdbb471dfe9a74b3a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a> = uint32_t</td></tr>
<tr class="memdesc:ab6227d2a40d02dbdbb471dfe9a74b3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for node attribute bits.  <a href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">More...</a><br /></td></tr>
<tr class="separator:ab6227d2a40d02dbdbb471dfe9a74b3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43a92b1246481aaae75580bc46c17ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad43a92b1246481aaae75580bc46c17ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ad43a92b1246481aaae75580bc46c17ea">is_constructible_mapping_type</a> = <a class="el" href="structconjunction.html">conjunction</a>&lt; <a class="el" href="namespacedetect.html#affb3a084fde4974f3064ce9e9f0e1665">detect::has_key_type</a>&lt; T &gt;, <a class="el" href="namespacedetect.html#ab5db101970db1faec2887b4857f89b54">detect::has_mapped_type</a>&lt; T &gt;, <a class="el" href="namespacedetect.html#a5773069cbdb23777e6310c7d510445f9">detect::has_value_type</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ad43a92b1246481aaae75580bc46c17ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility traits type alias to detect constructible associative container types from a mapping node, e.g., std::map or std::unordered_map.  <a href="node_8hpp.html#ad43a92b1246481aaae75580bc46c17ea">More...</a><br /></td></tr>
<tr class="separator:ad43a92b1246481aaae75580bc46c17ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3056256dab12fe1854bb1225aa4a6fda"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T &gt; </td></tr>
<tr class="memitem:a3056256dab12fe1854bb1225aa4a6fda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3056256dab12fe1854bb1225aa4a6fda">is_constructible_sequence_type</a> = <a class="el" href="structconjunction.html">conjunction</a>&lt; <a class="el" href="structnegation.html">negation</a>&lt; <a class="el" href="structis__basic__node.html">is_basic_node</a>&lt; T &gt; &gt;, <a class="el" href="namespacedetect.html#afed08d4544a75e5712c1aa976a2e8c2e">detect::has_iterator</a>&lt; T &gt;, <a class="el" href="structdetect_1_1is__iterator__traits.html">detect::is_iterator_traits</a>&lt; typename T::iterator &gt;, <a class="el" href="structdetect_1_1has__begin__end.html">detect::has_begin_end</a>&lt; T &gt;, <a class="el" href="structnegation.html">negation</a>&lt; std::is_same&lt; T, typename BasicNodeType::mapping_type &gt; &gt;, <a class="el" href="structnegation.html">negation</a>&lt; <a class="el" href="node_8hpp.html#ad43a92b1246481aaae75580bc46c17ea">is_constructible_mapping_type</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a3056256dab12fe1854bb1225aa4a6fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility traits type alias to detect constructible container types from a sequence node, e.g., std::vector or std::list.  <a href="node_8hpp.html#a3056256dab12fe1854bb1225aa4a6fda">More...</a><br /></td></tr>
<tr class="separator:a3056256dab12fe1854bb1225aa4a6fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e968d716ada1ed7a862e4b814c8160d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e968d716ada1ed7a862e4b814c8160d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a4e968d716ada1ed7a862e4b814c8160d">is_sequence_container_adapter</a> = <a class="el" href="structconjunction.html">conjunction</a>&lt; <a class="el" href="structnegation.html">negation</a>&lt; <a class="el" href="structis__basic__node.html">is_basic_node</a>&lt; T &gt; &gt;, <a class="el" href="namespacedetect.html#acfb7e3d7d6761807e13d9ba9df2bf73f">detect::has_container_type</a>&lt; T &gt;, <a class="el" href="namespacedetect.html#a5773069cbdb23777e6310c7d510445f9">detect::has_value_type</a>&lt; T &gt;, <a class="el" href="structnegation.html">negation</a>&lt; <a class="el" href="namespacedetect.html#affb3a084fde4974f3064ce9e9f0e1665">detect::has_key_type</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a4e968d716ada1ed7a862e4b814c8160d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility traits type alias to detect a sequence container adapter type, e.g., std::stack or std::queue.  <a href="node_8hpp.html#a4e968d716ada1ed7a862e4b814c8160d">More...</a><br /></td></tr>
<tr class="separator:a4e968d716ada1ed7a862e4b814c8160d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3bda996ce6a4874f26ec3e41b9bbed12"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a> : std::uint8_t { <a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12ab4abd26b93226f8ce368709dd09c1eb7">VERSION_1_1</a>
, <a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12a5e2745357f1c8b7db5eb87d3c4fa8276">VERSION_1_2</a>
 }</td></tr>
<tr class="separator:a3bda996ce6a4874f26ec3e41b9bbed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881d85c4d69a945b007a50acdff3a238"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238a2cb198a10d0a4c217ff4c15e98a97215">SEQUENCE</a>
, <a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238a2fa399f11879d3347f324fe703fb9f97">MAPPING</a>
, <a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238a196d5ef10ed279d398e255615a96e3c8">NULL_OBJECT</a>
, <a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238ac48d5da12d702e73d6966069f2687376">BOOLEAN</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238a5d5cd46919fa987731fb2edefe0f2a0c">INTEGER</a>
, <a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238ae738c26bf4ce1037fa81b039a915cbf6">FLOAT</a>
, <a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238a63b588d5559f64f89a416e656880b949">STRING</a>
<br />
 }</td></tr>
<tr class="separator:a881d85c4d69a945b007a50acdff3a238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c260e5d2614f91330c3a14bb3dbc69"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69a2cb198a10d0a4c217ff4c15e98a97215">SEQUENCE</a>
, <a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69a2fa399f11879d3347f324fe703fb9f97">MAPPING</a>
, <a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69a196d5ef10ed279d398e255615a96e3c8">NULL_OBJECT</a>
, <a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69ac48d5da12d702e73d6966069f2687376">BOOLEAN</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69a5d5cd46919fa987731fb2edefe0f2a0c">INTEGER</a>
, <a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69a6917258a465575b46ffac54438f015f0">FLOAT_NUMBER</a>
, <a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69a63b588d5559f64f89a416e656880b949">STRING</a>
<br />
 }</td></tr>
<tr class="memdesc:a79c260e5d2614f91330c3a14bb3dbc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of node value types.  <a href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">More...</a><br /></td></tr>
<tr class="separator:a79c260e5d2614f91330c3a14bb3dbc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49eeff8a1d87cb6461bcb77d17e90f0b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a49eeff8a1d87cb6461bcb77d17e90f0b">chomping_indicator_t</a> : std::uint8_t { <a class="el" href="node_8hpp.html#a49eeff8a1d87cb6461bcb77d17e90f0ba6989032db1002ec3fb0b2de2c970f184">STRIP</a>
, <a class="el" href="node_8hpp.html#a49eeff8a1d87cb6461bcb77d17e90f0ba960f0b6c4711bd0a42965edec68192d8">CLIP</a>
, <a class="el" href="node_8hpp.html#a49eeff8a1d87cb6461bcb77d17e90f0ba60cba2874369bd3790e14ea5f8a7bc58">KEEP</a>
 }</td></tr>
<tr class="memdesc:a49eeff8a1d87cb6461bcb77d17e90f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of chomping indicator types.  <a href="node_8hpp.html#a49eeff8a1d87cb6461bcb77d17e90f0b">More...</a><br /></td></tr>
<tr class="separator:a49eeff8a1d87cb6461bcb77d17e90f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceb55f511a84f394fedd24623b92da7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7">lexical_token_t</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a8ccd9703eee6b8fb515999099ea7ec4f">END_OF_BUFFER</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a395c63e6ab17238cee38c76ef808861d">EXPLICIT_KEY_PREFIX</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a6ce05721da7b96323d74b4adcfbf9d8c">KEY_SEPARATOR</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a752a169eae200e7303f0e5fa443c3b13">VALUE_SEPARATOR</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a45ffec46a1c7e2801eb9f86516ddb8eb">ANCHOR_PREFIX</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7aa19d32cb5f8a9b49fc550d7b6a97624e">ALIAS_PREFIX</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a4bc4a2cd852d6d355e7e6f8ed183b526">YAML_VER_DIRECTIVE</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a245746579c7425e28c646fe2025a7a13">TAG_DIRECTIVE</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7afe2109d3d2eb7f07dfa579496f09c587">TAG_PREFIX</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7ac9a9219dfe74bd3ad1c359a2f1082822">INVALID_DIRECTIVE</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7ab3302bb793d4184a5b03f59c40524324">SEQUENCE_BLOCK_PREFIX</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a715aa81f74f0c2154ab2731e3bc1740d">SEQUENCE_FLOW_BEGIN</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a094b4c8fb93f5caecb434009ad980bf2">SEQUENCE_FLOW_END</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a2145e9ac1e0a05896ce1ffd6b409da9d">MAPPING_FLOW_BEGIN</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a08f9b8d85b2c451766f5ce81a299e104">MAPPING_FLOW_END</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a949110ba2f21240c4a046e088b372b4b">PLAIN_SCALAR</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a1067fbcafdf2ec86bff934d9532a7d29">SINGLE_QUOTED_SCALAR</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7adce0c8918a558088f218a6c99841d04b">DOUBLE_QUOTED_SCALAR</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a6bb661cb9de73d3ef01bf5cd6ca0197b">BLOCK_LITERAL_SCALAR</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a9c2859e65b5ae63faccaabffcc8cae7f">BLOCK_FOLDED_SCALAR</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a709103f395d7eda391d0f333d58083db">END_OF_DIRECTIVES</a>
, <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7a6447443a57d51c89977c8e5f4810be60">END_OF_DOCUMENT</a>
<br />
 }</td></tr>
<tr class="memdesc:a5ceb55f511a84f394fedd24623b92da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of lexical token types.  <a href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7">More...</a><br /></td></tr>
<tr class="separator:a5ceb55f511a84f394fedd24623b92da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6168e828235e127d08d4e2db07bf78"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78">tag_t</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78a3310eb2b813439167fac6b109b3708bf">NON_SPECIFIC</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78adeaa0224caf9e2728caefadd911896bf">CUSTOM_TAG</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78a2cb198a10d0a4c217ff4c15e98a97215">SEQUENCE</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78a2fa399f11879d3347f324fe703fb9f97">MAPPING</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78aa9f0aff2067f91437e50e4872b229e6a">NULL_VALUE</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78ac48d5da12d702e73d6966069f2687376">BOOLEAN</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78a5d5cd46919fa987731fb2edefe0f2a0c">INTEGER</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78a0cbd694d6a73cd1a32ccfac49adc5aba">FLOATING_NUMBER</a>
, <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78a63b588d5559f64f89a416e656880b949">STRING</a>
<br />
 }</td></tr>
<tr class="memdesc:a7d6168e828235e127d08d4e2db07bf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of YAML tag types.  <a href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78">More...</a><br /></td></tr>
<tr class="separator:a7d6168e828235e127d08d4e2db07bf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e8fa6d8c5f31d8eb035926b6daf081"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081">utf_encode_t</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081ad12edd24928a1130b74c1663a4391d24">UTF_8</a>
, <a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081af0353e63e27d6fc7704373c223db6d84">UTF_16BE</a>
, <a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081a986a072862269ae269f8e5d5d528a240">UTF_16LE</a>
, <a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081a392fc455715b4900922f22c51ff07af8">UTF_32BE</a>
, <br />
&#160;&#160;<a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081a07994caf33e677baa209ecf7ee18d5df">UTF_32LE</a>
<br />
 }</td></tr>
<tr class="memdesc:a36e8fa6d8c5f31d8eb035926b6daf081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of Unicode encoding types.  <a href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081">More...</a><br /></td></tr>
<tr class="separator:a36e8fa6d8c5f31d8eb035926b6daf081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c614d98ee86254fb432b2f82e7ebb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#acb8c614d98ee86254fb432b2f82e7ebb">iterator_t</a> : std::uint8_t { <a class="el" href="node_8hpp.html#acb8c614d98ee86254fb432b2f82e7ebba2cb198a10d0a4c217ff4c15e98a97215">SEQUENCE</a>
, <a class="el" href="node_8hpp.html#acb8c614d98ee86254fb432b2f82e7ebba2fa399f11879d3347f324fe703fb9f97">MAPPING</a>
 }</td></tr>
<tr class="memdesc:acb8c614d98ee86254fb432b2f82e7ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of iterator types for iterators internally held.  <a href="node_8hpp.html#acb8c614d98ee86254fb432b2f82e7ebb">More...</a><br /></td></tr>
<tr class="separator:acb8c614d98ee86254fb432b2f82e7ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4dc98d9921c270f750a2a1a16db7f1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">yaml_version_t</a> : std::uint8_t { <a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1ad3045c1425531ed63ca231cb15912ac0">VER_1_1</a>
, <a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1a11400a1295bbbfcbe91a1380b7d2d576">VER_1_2</a>
 }</td></tr>
<tr class="memdesc:a0a4dc98d9921c270f750a2a1a16db7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of YAML version types.  <a href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">More...</a><br /></td></tr>
<tr class="separator:a0a4dc98d9921c270f750a2a1a16db7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98a996adc7ad22a8dc75b936e74b73ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a98a996adc7ad22a8dc75b936e74b73ca">unreachable</a> ()</td></tr>
<tr class="memdesc:a98a996adc7ad22a8dc75b936e74b73ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function to call std::unreachable() (since C++23) or similar compiler specific extensions.  <a href="node_8hpp.html#a98a996adc7ad22a8dc75b936e74b73ca">More...</a><br /></td></tr>
<tr class="separator:a98a996adc7ad22a8dc75b936e74b73ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae303a43856edd89e2f47a45be344c53c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string</a> (<a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a> t) noexcept</td></tr>
<tr class="separator:ae303a43856edd89e2f47a45be344c53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080bd0fe1a31859ecfd4d6fe93424385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a080bd0fe1a31859ecfd4d6fe93424385">format</a> (const char *fmt,...)</td></tr>
<tr class="separator:a080bd0fe1a31859ecfd4d6fe93424385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739a032ed975329a1f63b4e0e0e11e4f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a739a032ed975329a1f63b4e0e0e11e4f">to_string</a> (<a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a> t) noexcept</td></tr>
<tr class="separator:a739a032ed975329a1f63b4e0e0e11e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa18fda8896a73b564c07839c69a16"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a18aa18fda8896a73b564c07839c69a16">to_string</a> (<a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a> t) noexcept</td></tr>
<tr class="separator:a18aa18fda8896a73b564c07839c69a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a0f3d345d6af75503ed4966a0f6175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a87a0f3d345d6af75503ed4966a0f6175">convert_from_node_type</a> (<a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a> t)</td></tr>
<tr class="separator:a87a0f3d345d6af75503ed4966a0f6175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e448edff68fac084e9967c004d1a669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6e448edff68fac084e9967c004d1a669">convert_to_node_type</a> (<a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a> t)</td></tr>
<tr class="separator:a6e448edff68fac084e9967c004d1a669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa546611ec8c986d56c38b07a8332cb76"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutf8.html#aa546611ec8c986d56c38b07a8332cb76">utf8::get_num_bytes</a> (uint8_t first_byte)</td></tr>
<tr class="memdesc:aa546611ec8c986d56c38b07a8332cb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of UTF-8 character bytes with the first byte.  <a href="namespaceutf8.html#aa546611ec8c986d56c38b07a8332cb76">More...</a><br /></td></tr>
<tr class="separator:aa546611ec8c986d56c38b07a8332cb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9460577477e10d64c54ed0b63f3deea7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutf8.html#a9460577477e10d64c54ed0b63f3deea7">utf8::validate</a> (const std::initializer_list&lt; uint8_t &gt; &amp;byte_array) noexcept</td></tr>
<tr class="memdesc:a9460577477e10d64c54ed0b63f3deea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the encoding of a given byte array whose length is 1.  <a href="namespaceutf8.html#a9460577477e10d64c54ed0b63f3deea7">More...</a><br /></td></tr>
<tr class="separator:a9460577477e10d64c54ed0b63f3deea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956f5d28144b4b051669c60f56069071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutf8.html#a956f5d28144b4b051669c60f56069071">utf8::from_utf16</a> (std::array&lt; char16_t, 2 &gt; utf16, std::array&lt; uint8_t, 4 &gt; &amp;utf8, uint32_t &amp;consumed_size, uint32_t &amp;encoded_size)</td></tr>
<tr class="memdesc:a956f5d28144b4b051669c60f56069071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts UTF-16 encoded characters to UTF-8 encoded bytes.  <a href="namespaceutf8.html#a956f5d28144b4b051669c60f56069071">More...</a><br /></td></tr>
<tr class="separator:a956f5d28144b4b051669c60f56069071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6775e036faed5320df82ac3be7d8ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutf8.html#ade6775e036faed5320df82ac3be7d8ae">utf8::from_utf32</a> (const char32_t utf32, std::array&lt; uint8_t, 4 &gt; &amp;utf8, uint32_t &amp;encoded_size)</td></tr>
<tr class="memdesc:ade6775e036faed5320df82ac3be7d8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-32 encoded character to UTF-8 encoded bytes.  <a href="namespaceutf8.html#ade6775e036faed5320df82ac3be7d8ae">More...</a><br /></td></tr>
<tr class="separator:ade6775e036faed5320df82ac3be7d8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9ae1d88ac076f895fcd1da0332a77f"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:adf9ae1d88ac076f895fcd1da0332a77f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#adf9ae1d88ac076f895fcd1da0332a77f">operator==</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:adf9ae1d88ac076f895fcd1da0332a77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#adf9ae1d88ac076f895fcd1da0332a77f">More...</a><br /></td></tr>
<tr class="separator:adf9ae1d88ac076f895fcd1da0332a77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d30d2909ef9980b0adcaec96f1d5d4"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab0d30d2909ef9980b0adcaec96f1d5d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab0d30d2909ef9980b0adcaec96f1d5d4">operator==</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab0d30d2909ef9980b0adcaec96f1d5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#ab0d30d2909ef9980b0adcaec96f1d5d4">More...</a><br /></td></tr>
<tr class="separator:ab0d30d2909ef9980b0adcaec96f1d5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad6a835351b58683eb81b5dd899805f"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:acad6a835351b58683eb81b5dd899805f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#acad6a835351b58683eb81b5dd899805f">operator==</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:acad6a835351b58683eb81b5dd899805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#acad6a835351b58683eb81b5dd899805f">More...</a><br /></td></tr>
<tr class="separator:acad6a835351b58683eb81b5dd899805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa4e4d656b1145e9926a83e8a31f382"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a3aa4e4d656b1145e9926a83e8a31f382"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3aa4e4d656b1145e9926a83e8a31f382">operator==</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, const CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="memdesc:a3aa4e4d656b1145e9926a83e8a31f382"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a3aa4e4d656b1145e9926a83e8a31f382">More...</a><br /></td></tr>
<tr class="separator:a3aa4e4d656b1145e9926a83e8a31f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3607abeabbeec28c649eb1b492a3232"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ae3607abeabbeec28c649eb1b492a3232"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ae3607abeabbeec28c649eb1b492a3232">operator==</a> (const CharT(&amp;lhs)[N], <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ae3607abeabbeec28c649eb1b492a3232"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#ae3607abeabbeec28c649eb1b492a3232">More...</a><br /></td></tr>
<tr class="separator:ae3607abeabbeec28c649eb1b492a3232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c25e15264dc232b05aa2f8c04c738a6"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a8c25e15264dc232b05aa2f8c04c738a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8c25e15264dc232b05aa2f8c04c738a6">operator!=</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a8c25e15264dc232b05aa2f8c04c738a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a8c25e15264dc232b05aa2f8c04c738a6">More...</a><br /></td></tr>
<tr class="separator:a8c25e15264dc232b05aa2f8c04c738a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3648615788af27dad431b27984526c2"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ac3648615788af27dad431b27984526c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ac3648615788af27dad431b27984526c2">operator!=</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, const std::basic_string&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac3648615788af27dad431b27984526c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#ac3648615788af27dad431b27984526c2">More...</a><br /></td></tr>
<tr class="separator:ac3648615788af27dad431b27984526c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a177312a4feaaffcb455795a1fef214"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a6a177312a4feaaffcb455795a1fef214"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6a177312a4feaaffcb455795a1fef214">operator!=</a> (const std::basic_string&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a6a177312a4feaaffcb455795a1fef214"><td class="mdescLeft">&#160;</td><td class="mdescRight">An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a6a177312a4feaaffcb455795a1fef214">More...</a><br /></td></tr>
<tr class="separator:a6a177312a4feaaffcb455795a1fef214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306ab36f4b207c85b76a9381d32079bb"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a306ab36f4b207c85b76a9381d32079bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a306ab36f4b207c85b76a9381d32079bb">operator!=</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, const CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="memdesc:a306ab36f4b207c85b76a9381d32079bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a306ab36f4b207c85b76a9381d32079bb">More...</a><br /></td></tr>
<tr class="separator:a306ab36f4b207c85b76a9381d32079bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4c76d958de4f8fb0e037003a2b2027"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a5b4c76d958de4f8fb0e037003a2b2027"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5b4c76d958de4f8fb0e037003a2b2027">operator!=</a> (const CharT(&amp;lhs)[N], <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a5b4c76d958de4f8fb0e037003a2b2027"><td class="mdescLeft">&#160;</td><td class="mdescRight">An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a5b4c76d958de4f8fb0e037003a2b2027">More...</a><br /></td></tr>
<tr class="separator:a5b4c76d958de4f8fb0e037003a2b2027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac030c1203c78961571cf965abfb375"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aeac030c1203c78961571cf965abfb375"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aeac030c1203c78961571cf965abfb375">operator&lt;</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:aeac030c1203c78961571cf965abfb375"><td class="mdescLeft">&#160;</td><td class="mdescRight">An less-than operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#aeac030c1203c78961571cf965abfb375">More...</a><br /></td></tr>
<tr class="separator:aeac030c1203c78961571cf965abfb375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e5a95d6d2d174506bb170137e05a15"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a31e5a95d6d2d174506bb170137e05a15"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a31e5a95d6d2d174506bb170137e05a15">operator&lt;=</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a31e5a95d6d2d174506bb170137e05a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">An less-than-or-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a31e5a95d6d2d174506bb170137e05a15">More...</a><br /></td></tr>
<tr class="separator:a31e5a95d6d2d174506bb170137e05a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35fa4ea827bf42466e1e056f736720"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:afc35fa4ea827bf42466e1e056f736720"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#afc35fa4ea827bf42466e1e056f736720">operator&gt;</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:afc35fa4ea827bf42466e1e056f736720"><td class="mdescLeft">&#160;</td><td class="mdescRight">An greater-than operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#afc35fa4ea827bf42466e1e056f736720">More...</a><br /></td></tr>
<tr class="separator:afc35fa4ea827bf42466e1e056f736720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c94f5b59efcb4c687dba416785d5ecf"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a2c94f5b59efcb4c687dba416785d5ecf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2c94f5b59efcb4c687dba416785d5ecf">operator&gt;=</a> (<a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; lhs, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a2c94f5b59efcb4c687dba416785d5ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An greater-than-or-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#a2c94f5b59efcb4c687dba416785d5ecf">More...</a><br /></td></tr>
<tr class="separator:a2c94f5b59efcb4c687dba416785d5ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ab4bba30e7d61f15a8c5872a29bea1"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae1ab4bba30e7d61f15a8c5872a29bea1"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ae1ab4bba30e7d61f15a8c5872a29bea1">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;os, <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt; sv)</td></tr>
<tr class="memdesc:ae1ab4bba30e7d61f15a8c5872a29bea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class.  <a href="node_8hpp.html#ae1ab4bba30e7d61f15a8c5872a29bea1">More...</a><br /></td></tr>
<tr class="separator:ae1ab4bba30e7d61f15a8c5872a29bea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf750e9f3995dfa48df7bbad443c087f"><td class="memTemplParams" colspan="2">template&lt;typename CharItr &gt; </td></tr>
<tr class="memitem:adf750e9f3995dfa48df7bbad443c087f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#adf750e9f3995dfa48df7bbad443c087f">aton</a> (CharItr begin, CharItr end, std::nullptr_t &amp;) noexcept</td></tr>
<tr class="memdesc:adf750e9f3995dfa48df7bbad443c087f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into a null value.  <a href="node_8hpp.html#adf750e9f3995dfa48df7bbad443c087f">More...</a><br /></td></tr>
<tr class="separator:adf750e9f3995dfa48df7bbad443c087f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407416834912e052f6c9d2df7fa1158e"><td class="memTemplParams" colspan="2">template&lt;typename CharItr , typename BoolType &gt; </td></tr>
<tr class="memitem:a407416834912e052f6c9d2df7fa1158e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a407416834912e052f6c9d2df7fa1158e">atob</a> (CharItr begin, CharItr end, BoolType &amp;boolean) noexcept</td></tr>
<tr class="memdesc:a407416834912e052f6c9d2df7fa1158e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into a boolean value.  <a href="node_8hpp.html#a407416834912e052f6c9d2df7fa1158e">More...</a><br /></td></tr>
<tr class="separator:a407416834912e052f6c9d2df7fa1158e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c19dc5ee52703d61ea795aaa3c6cbc3"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a2c19dc5ee52703d61ea795aaa3c6cbc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2c19dc5ee52703d61ea795aaa3c6cbc3">atoi_dec_unchecked</a> (const char *p_begin, const char *p_end, IntType &amp;i) noexcept</td></tr>
<tr class="memdesc:a2c19dc5ee52703d61ea795aaa3c6cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into decimals.  <a href="node_8hpp.html#a2c19dc5ee52703d61ea795aaa3c6cbc3">More...</a><br /></td></tr>
<tr class="separator:a2c19dc5ee52703d61ea795aaa3c6cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68044668c544bc95d107d7c1877ad255"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a68044668c544bc95d107d7c1877ad255"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a68044668c544bc95d107d7c1877ad255">atoi_dec_pos</a> (const char *p_begin, const char *p_end, IntType &amp;i) noexcept</td></tr>
<tr class="memdesc:a68044668c544bc95d107d7c1877ad255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into positive decimals.  <a href="node_8hpp.html#a68044668c544bc95d107d7c1877ad255">More...</a><br /></td></tr>
<tr class="separator:a68044668c544bc95d107d7c1877ad255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c6ec43248fb527250ec8f6d1aa562a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a86c6ec43248fb527250ec8f6d1aa562a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a86c6ec43248fb527250ec8f6d1aa562a">atoi_dec_neg</a> (const char *p_begin, const char *p_end, IntType &amp;i) noexcept</td></tr>
<tr class="memdesc:a86c6ec43248fb527250ec8f6d1aa562a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into negative decimals.  <a href="node_8hpp.html#a86c6ec43248fb527250ec8f6d1aa562a">More...</a><br /></td></tr>
<tr class="separator:a86c6ec43248fb527250ec8f6d1aa562a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d37d989b14246546efcde4048570371"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a3d37d989b14246546efcde4048570371"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3d37d989b14246546efcde4048570371">atoi_oct</a> (const char *p_begin, const char *p_end, IntType &amp;i) noexcept</td></tr>
<tr class="memdesc:a3d37d989b14246546efcde4048570371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into octals.  <a href="node_8hpp.html#a3d37d989b14246546efcde4048570371">More...</a><br /></td></tr>
<tr class="separator:a3d37d989b14246546efcde4048570371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f472c0e6d68778599ab1ebf91678c3e"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a4f472c0e6d68778599ab1ebf91678c3e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a4f472c0e6d68778599ab1ebf91678c3e">atoi_hex</a> (const char *p_begin, const char *p_end, IntType &amp;i) noexcept</td></tr>
<tr class="memdesc:a4f472c0e6d68778599ab1ebf91678c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into hexadecimals.  <a href="node_8hpp.html#a4f472c0e6d68778599ab1ebf91678c3e">More...</a><br /></td></tr>
<tr class="separator:a4f472c0e6d68778599ab1ebf91678c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab824250dc8d429b714badf711ca8c6d0"><td class="memTemplParams" colspan="2">template&lt;typename CharItr , typename IntType &gt; </td></tr>
<tr class="memitem:ab824250dc8d429b714badf711ca8c6d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab824250dc8d429b714badf711ca8c6d0">atoi</a> (CharItr begin, CharItr end, IntType &amp;i) noexcept</td></tr>
<tr class="memdesc:ab824250dc8d429b714badf711ca8c6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into integers.  <a href="node_8hpp.html#ab824250dc8d429b714badf711ca8c6d0">More...</a><br /></td></tr>
<tr class="separator:ab824250dc8d429b714badf711ca8c6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a222a41f9b400287a99ade41820af1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aa3a222a41f9b400287a99ade41820af1">set_infinity</a> (float &amp;f, const float sign) noexcept</td></tr>
<tr class="memdesc:aa3a222a41f9b400287a99ade41820af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an infinite <code>float</code> value based on the given signedness.  <a href="node_8hpp.html#aa3a222a41f9b400287a99ade41820af1">More...</a><br /></td></tr>
<tr class="separator:aa3a222a41f9b400287a99ade41820af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cff770c980f926ed26bbbd642c2d0b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6cff770c980f926ed26bbbd642c2d0b6">set_infinity</a> (double &amp;f, const double sign) noexcept</td></tr>
<tr class="memdesc:a6cff770c980f926ed26bbbd642c2d0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an infinite <code>double</code> value based on the given signedness.  <a href="node_8hpp.html#a6cff770c980f926ed26bbbd642c2d0b6">More...</a><br /></td></tr>
<tr class="separator:a6cff770c980f926ed26bbbd642c2d0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51465e1fa382ddba53933393ed698818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a51465e1fa382ddba53933393ed698818">set_nan</a> (float &amp;f) noexcept</td></tr>
<tr class="memdesc:a51465e1fa382ddba53933393ed698818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a NaN <code>float</code> value.  <a href="node_8hpp.html#a51465e1fa382ddba53933393ed698818">More...</a><br /></td></tr>
<tr class="separator:a51465e1fa382ddba53933393ed698818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a8ca42d762a253f0d1f7cdd2f2c281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a30a8ca42d762a253f0d1f7cdd2f2c281">set_nan</a> (double &amp;f) noexcept</td></tr>
<tr class="memdesc:a30a8ca42d762a253f0d1f7cdd2f2c281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a NaN <code>double</code> value.  <a href="node_8hpp.html#a30a8ca42d762a253f0d1f7cdd2f2c281">More...</a><br /></td></tr>
<tr class="separator:a30a8ca42d762a253f0d1f7cdd2f2c281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0559d8ae0567d95092047d4b2ffc89a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aa0559d8ae0567d95092047d4b2ffc89a">atof_impl</a> (const char *p_begin, const char *p_end, float &amp;f)</td></tr>
<tr class="memdesc:aa0559d8ae0567d95092047d4b2ffc89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into a <code>float</code> value.  <a href="node_8hpp.html#aa0559d8ae0567d95092047d4b2ffc89a">More...</a><br /></td></tr>
<tr class="separator:aa0559d8ae0567d95092047d4b2ffc89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfcf131f3ab958ee6a64124709ce262"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#abbfcf131f3ab958ee6a64124709ce262">atof_impl</a> (const char *p_begin, const char *p_end, double &amp;f)</td></tr>
<tr class="memdesc:abbfcf131f3ab958ee6a64124709ce262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into a <code>double</code> value.  <a href="node_8hpp.html#abbfcf131f3ab958ee6a64124709ce262">More...</a><br /></td></tr>
<tr class="separator:abbfcf131f3ab958ee6a64124709ce262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f880e86dacd75b2acfa6bd496fd5f8c"><td class="memTemplParams" colspan="2">template&lt;typename CharItr , typename FloatType &gt; </td></tr>
<tr class="memitem:a7f880e86dacd75b2acfa6bd496fd5f8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7f880e86dacd75b2acfa6bd496fd5f8c">atof</a> (CharItr begin, CharItr end, FloatType &amp;f) noexcept(noexcept(<a class="el" href="node_8hpp.html#abbfcf131f3ab958ee6a64124709ce262">atof_impl</a>(&amp;*begin, &amp;*begin, f)))</td></tr>
<tr class="memdesc:a7f880e86dacd75b2acfa6bd496fd5f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar into a floating point value.  <a href="node_8hpp.html#a7f880e86dacd75b2acfa6bd496fd5f8c">More...</a><br /></td></tr>
<tr class="separator:a7f880e86dacd75b2acfa6bd496fd5f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b22cfa621560568f1e2850cbbae823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a26b22cfa621560568f1e2850cbbae823">node_attr_bits::from_node_type</a> (<a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a> t) noexcept</td></tr>
<tr class="memdesc:a26b22cfa621560568f1e2850cbbae823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a node_type value to a node_attr_t value.  <a href="namespacenode__attr__bits.html#a26b22cfa621560568f1e2850cbbae823">More...</a><br /></td></tr>
<tr class="separator:a26b22cfa621560568f1e2850cbbae823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1834a3835687c5be26811852427201c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a1834a3835687c5be26811852427201c2">node_attr_bits::to_node_type</a> (<a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a> bits) noexcept</td></tr>
<tr class="memdesc:a1834a3835687c5be26811852427201c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a node_attr_t value to a node_type value.  <a href="namespacenode__attr__bits.html#a1834a3835687c5be26811852427201c2">More...</a><br /></td></tr>
<tr class="separator:a1834a3835687c5be26811852427201c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfbe22575456057bd132bc2cd0fc222"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#accfbe22575456057bd132bc2cd0fc222">node_attr_bits::get_anchor_offset</a> (<a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a> attrs) noexcept</td></tr>
<tr class="memdesc:accfbe22575456057bd132bc2cd0fc222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an anchor offset used to reference an anchor node from the given attribute bits.  <a href="namespacenode__attr__bits.html#accfbe22575456057bd132bc2cd0fc222">More...</a><br /></td></tr>
<tr class="separator:accfbe22575456057bd132bc2cd0fc222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229b05b89bef24630d2d4a2aa27b0f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a229b05b89bef24630d2d4a2aa27b0f5c">node_attr_bits::set_anchor_offset</a> (uint32_t offset, <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a> &amp;attrs) noexcept</td></tr>
<tr class="memdesc:a229b05b89bef24630d2d4a2aa27b0f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an anchor offset value to the appropriate bits.  <a href="namespacenode__attr__bits.html#a229b05b89bef24630d2d4a2aa27b0f5c">More...</a><br /></td></tr>
<tr class="separator:a229b05b89bef24630d2d4a2aa27b0f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6de76a90a8fda06d8b0b38f88c50590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#ab8cc808373a7ff2e6615c65c32675dd7">FK_YAML_DETAIL_NAMESPACE_END</a> <a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a> <a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081">utf_encode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ac6de76a90a8fda06d8b0b38f88c50590">detect_encoding_type</a> (const std::array&lt; uint8_t, 4 &gt; &amp;bytes, bool &amp;has_bom) noexcept</td></tr>
<tr class="memdesc:ac6de76a90a8fda06d8b0b38f88c50590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect an encoding type for UTF-8 expected inputs.  <a href="node_8hpp.html#ac6de76a90a8fda06d8b0b38f88c50590">More...</a><br /></td></tr>
<tr class="separator:ac6de76a90a8fda06d8b0b38f88c50590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c87ddd8cc61a5140db7fed537568a35"><td class="memTemplParams" colspan="2">template&lt;typename ItrType &gt; </td></tr>
<tr class="memitem:a5c87ddd8cc61a5140db7fed537568a35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a>&lt; ItrType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5c87ddd8cc61a5140db7fed537568a35">create_iterator_input_adapter</a> (ItrType begin, ItrType end, bool is_contiguous)</td></tr>
<tr class="memdesc:a5c87ddd8cc61a5140db7fed537568a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with iterators.  <a href="node_8hpp.html#a5c87ddd8cc61a5140db7fed537568a35">More...</a><br /></td></tr>
<tr class="separator:a5c87ddd8cc61a5140db7fed537568a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156e537c246c50d9586cd12f9dca0b58"><td class="memTemplParams" colspan="2">template&lt;typename ItrType &gt; </td></tr>
<tr class="memitem:a156e537c246c50d9586cd12f9dca0b58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a>&lt; ItrType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a156e537c246c50d9586cd12f9dca0b58">input_adapter</a> (ItrType begin, ItrType end)</td></tr>
<tr class="memdesc:a156e537c246c50d9586cd12f9dca0b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with iterator values.  <a href="node_8hpp.html#a156e537c246c50d9586cd12f9dca0b58">More...</a><br /></td></tr>
<tr class="separator:a156e537c246c50d9586cd12f9dca0b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcf5ce57960cc91c427eaf5264d2377"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0fcf5ce57960cc91c427eaf5264d2377"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a0fcf5ce57960cc91c427eaf5264d2377">input_adapter</a> (T(&amp;array)[N]) -&gt; decltype(<a class="el" href="node_8hpp.html#a5c87ddd8cc61a5140db7fed537568a35">create_iterator_input_adapter</a>(array, array+(N - 1), true))</td></tr>
<tr class="memdesc:a0fcf5ce57960cc91c427eaf5264d2377"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with C-style arrays.  <a href="node_8hpp.html#a0fcf5ce57960cc91c427eaf5264d2377">More...</a><br /></td></tr>
<tr class="separator:a0fcf5ce57960cc91c427eaf5264d2377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647c7f6557332490e9835c478745fb7"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a3647c7f6557332490e9835c478745fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structinput__adapter__factory_1_1container__input__adapter__factory.html">input_adapter_factory::container_input_adapter_factory</a>&lt; ContainerType &gt;::adapter_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3647c7f6557332490e9835c478745fb7">input_adapter</a> (const ContainerType &amp;container)</td></tr>
<tr class="memdesc:a3647c7f6557332490e9835c478745fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with containers.  <a href="node_8hpp.html#a3647c7f6557332490e9835c478745fb7">More...</a><br /></td></tr>
<tr class="separator:a3647c7f6557332490e9835c478745fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ca0bd6f4f7a1d2f056e77b0b97c8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfile__input__adapter.html">file_input_adapter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#af4ca0bd6f4f7a1d2f056e77b0b97c8b2">input_adapter</a> (std::FILE *file)</td></tr>
<tr class="memdesc:af4ca0bd6f4f7a1d2f056e77b0b97c8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory method for <a class="el" href="classfile__input__adapter.html" title="An input adapter for C-style file handles.">file_input_adapter</a> objects with C-style file handles.  <a href="node_8hpp.html#af4ca0bd6f4f7a1d2f056e77b0b97c8b2">More...</a><br /></td></tr>
<tr class="separator:af4ca0bd6f4f7a1d2f056e77b0b97c8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af703e0ffe80be5f9a9a6cc2c1dc5169a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstream__input__adapter.html">stream_input_adapter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#af703e0ffe80be5f9a9a6cc2c1dc5169a">input_adapter</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:af703e0ffe80be5f9a9a6cc2c1dc5169a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory method for <a class="el" href="classstream__input__adapter.html" title="An input adapter for streams.">stream_input_adapter</a> objects with std::istream objects.  <a href="node_8hpp.html#af703e0ffe80be5f9a9a6cc2c1dc5169a">More...</a><br /></td></tr>
<tr class="separator:af703e0ffe80be5f9a9a6cc2c1dc5169a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227cd25b227590e73a65a9e8fa498c23"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CharType &gt; </td></tr>
<tr class="memitem:a227cd25b227590e73a65a9e8fa498c23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a227cd25b227590e73a65a9e8fa498c23">to_string</a> (ValueType v, std::basic_string&lt; CharType &gt; &amp;s) noexcept</td></tr>
<tr class="memdesc:a227cd25b227590e73a65a9e8fa498c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ValueType object to a string YAML token.  <a href="node_8hpp.html#a227cd25b227590e73a65a9e8fa498c23">More...</a><br /></td></tr>
<tr class="separator:a227cd25b227590e73a65a9e8fa498c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a70ab2f61462f6c8e8f6b7eaa15d40d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3a70ab2f61462f6c8e8f6b7eaa15d40d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3a70ab2f61462f6c8e8f6b7eaa15d40d">to_string</a> (std::nullptr_t, std::string &amp;s) noexcept</td></tr>
<tr class="memdesc:a3a70ab2f61462f6c8e8f6b7eaa15d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for null values.  <a href="node_8hpp.html#a3a70ab2f61462f6c8e8f6b7eaa15d40d">More...</a><br /></td></tr>
<tr class="separator:a3a70ab2f61462f6c8e8f6b7eaa15d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592dfcb4b1f723556a02bc01128ed90"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6592dfcb4b1f723556a02bc01128ed90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6592dfcb4b1f723556a02bc01128ed90">to_string</a> (bool v, std::string &amp;s) noexcept</td></tr>
<tr class="memdesc:a6592dfcb4b1f723556a02bc01128ed90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for booleans.  <a href="node_8hpp.html#a6592dfcb4b1f723556a02bc01128ed90">More...</a><br /></td></tr>
<tr class="separator:a6592dfcb4b1f723556a02bc01128ed90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487dc2227c645d9124e23186d0cbe649"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType &gt; </td></tr>
<tr class="memitem:a487dc2227c645d9124e23186d0cbe649"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">enable_if_t</a>&lt; <a class="el" href="structis__non__bool__integral.html">is_non_bool_integral</a>&lt; IntegerType &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a487dc2227c645d9124e23186d0cbe649">to_string</a> (IntegerType v, std::string &amp;s) noexcept</td></tr>
<tr class="memdesc:a487dc2227c645d9124e23186d0cbe649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for integers.  <a href="node_8hpp.html#a487dc2227c645d9124e23186d0cbe649">More...</a><br /></td></tr>
<tr class="separator:a487dc2227c645d9124e23186d0cbe649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6074c9da5c716deed1534a06fe7ea13b"><td class="memTemplParams" colspan="2">template&lt;typename FloatType &gt; </td></tr>
<tr class="memitem:a6074c9da5c716deed1534a06fe7ea13b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">enable_if_t</a>&lt; std::is_floating_point&lt; FloatType &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a6074c9da5c716deed1534a06fe7ea13b">to_string</a> (FloatType v, std::string &amp;s) noexcept</td></tr>
<tr class="memdesc:a6074c9da5c716deed1534a06fe7ea13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for floating point numbers.  <a href="node_8hpp.html#a6074c9da5c716deed1534a06fe7ea13b">More...</a><br /></td></tr>
<tr class="separator:a6074c9da5c716deed1534a06fe7ea13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9437fc9d4044aa1c12ba6ec8517fb176"><td class="memTemplParams" colspan="2">template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:a9437fc9d4044aa1c12ba6ec8517fb176"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a9437fc9d4044aa1c12ba6ec8517fb176">operator==</a> (const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;lhs, const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;rhs)</td></tr>
<tr class="separator:a9437fc9d4044aa1c12ba6ec8517fb176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e17c1b3969098e06bcb7fd946edc9d"><td class="memTemplParams" colspan="2">template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ad5e17c1b3969098e06bcb7fd946edc9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ad5e17c1b3969098e06bcb7fd946edc9d">operator!=</a> (const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;lhs, const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;rhs)</td></tr>
<tr class="separator:ad5e17c1b3969098e06bcb7fd946edc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049293eb0eb750086eba27100580ed2a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:a049293eb0eb750086eba27100580ed2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a049293eb0eb750086eba27100580ed2a">operator&lt;</a> (const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;lhs, const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;rhs)</td></tr>
<tr class="separator:a049293eb0eb750086eba27100580ed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd519e927cc2a82af686706a53ef9c6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:a3dd519e927cc2a82af686706a53ef9c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a3dd519e927cc2a82af686706a53ef9c6">operator&lt;=</a> (const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;lhs, const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;rhs)</td></tr>
<tr class="separator:a3dd519e927cc2a82af686706a53ef9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54918863d13121bea9f8e12e3a67b5c6"><td class="memTemplParams" colspan="2">template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:a54918863d13121bea9f8e12e3a67b5c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a54918863d13121bea9f8e12e3a67b5c6">operator&gt;</a> (const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;lhs, const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;rhs)</td></tr>
<tr class="separator:a54918863d13121bea9f8e12e3a67b5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a95142255f79a218825a934f36935e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ac2a95142255f79a218825a934f36935e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ac2a95142255f79a218825a934f36935e">operator&gt;=</a> (const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;lhs, const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;rhs)</td></tr>
<tr class="separator:ac2a95142255f79a218825a934f36935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6d843f6f02257158312b1d6b819dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">yaml_version_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a1ae6d843f6f02257158312b1d6b819dd">convert_from_yaml_version_type</a> (<a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a> t) noexcept</td></tr>
<tr class="separator:a1ae6d843f6f02257158312b1d6b819dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8290add221fab99a59ea12426adf16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a8c8290add221fab99a59ea12426adf16">convert_to_yaml_version_type</a> (<a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">yaml_version_t</a> t) noexcept</td></tr>
<tr class="separator:a8c8290add221fab99a59ea12426adf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0d5c40a6de221a83f83e64b65632c2"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aad0d5c40a6de221a83f83e64b65632c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aad0d5c40a6de221a83f83e64b65632c2">from_node</a> (const BasicNodeType &amp;n, T(&amp;array)[N]) -&gt; decltype(n.get_value_inplace(std::declval&lt; T &amp; &gt;()), void())</td></tr>
<tr class="memdesc:aad0d5c40a6de221a83f83e64b65632c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for C-style 1D arrays whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#aad0d5c40a6de221a83f83e64b65632c2">More...</a><br /></td></tr>
<tr class="separator:aad0d5c40a6de221a83f83e64b65632c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203303bf1b8f348a4414a60d180d0353"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , std::size_t N0, std::size_t N1&gt; </td></tr>
<tr class="memitem:a203303bf1b8f348a4414a60d180d0353"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a203303bf1b8f348a4414a60d180d0353">from_node</a> (const BasicNodeType &amp;n, T(&amp;array)[N0][N1]) -&gt; decltype(n.get_value_inplace(std::declval&lt; T &amp; &gt;()), void())</td></tr>
<tr class="memdesc:a203303bf1b8f348a4414a60d180d0353"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for C-style 2D arrays whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#a203303bf1b8f348a4414a60d180d0353">More...</a><br /></td></tr>
<tr class="separator:a203303bf1b8f348a4414a60d180d0353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d5a2217392100beb5f979cebc0c5c1"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , std::size_t N0, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:ad7d5a2217392100beb5f979cebc0c5c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ad7d5a2217392100beb5f979cebc0c5c1">from_node</a> (const BasicNodeType &amp;n, T(&amp;array)[N0][N1][N2]) -&gt; decltype(n.get_value_inplace(std::declval&lt; T &amp; &gt;()), void())</td></tr>
<tr class="memdesc:ad7d5a2217392100beb5f979cebc0c5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for C-style 2D arrays whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#ad7d5a2217392100beb5f979cebc0c5c1">More...</a><br /></td></tr>
<tr class="separator:ad7d5a2217392100beb5f979cebc0c5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea665683f882f372a47d6260f259550"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:acea665683f882f372a47d6260f259550"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#acea665683f882f372a47d6260f259550">from_node</a> (const BasicNodeType &amp;n, std::array&lt; T, N &gt; &amp;arr) -&gt; decltype(n.get_value_inplace(std::declval&lt; T &amp; &gt;()), void())</td></tr>
<tr class="memdesc:acea665683f882f372a47d6260f259550"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for std::array objects whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#acea665683f882f372a47d6260f259550">More...</a><br /></td></tr>
<tr class="separator:acea665683f882f372a47d6260f259550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12c5bde31d20ab00af457554838c81d"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T &gt; </td></tr>
<tr class="memitem:ab12c5bde31d20ab00af457554838c81d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab12c5bde31d20ab00af457554838c81d">from_node</a> (const BasicNodeType &amp;n, std::valarray&lt; T &gt; &amp;va) -&gt; decltype(n.get_value_inplace(std::declval&lt; T &amp; &gt;()), void())</td></tr>
<tr class="memdesc:ab12c5bde31d20ab00af457554838c81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for std::valarray objects whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#ab12c5bde31d20ab00af457554838c81d">More...</a><br /></td></tr>
<tr class="separator:ab12c5bde31d20ab00af457554838c81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43611f94799f9766ee31983a727975d"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:ab43611f94799f9766ee31983a727975d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ab43611f94799f9766ee31983a727975d">from_node</a> (const BasicNodeType &amp;n, std::forward_list&lt; T, Alloc &gt; &amp;fl) -&gt; decltype(n.template get_value&lt; T &gt;(), void())</td></tr>
<tr class="memdesc:ab43611f94799f9766ee31983a727975d"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for std::forward_list objects whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#ab43611f94799f9766ee31983a727975d">More...</a><br /></td></tr>
<tr class="separator:ab43611f94799f9766ee31983a727975d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011b78a17b1e0b8b7963d5f88eac48af"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename CompatSeqType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, is_constructible_sequence_type&lt; BasicNodeType, CompatSeqType &gt;, negation&lt; std::is_constructible&lt; typename BasicNodeType::string_type, CompatSeqType &gt;&gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a011b78a17b1e0b8b7963d5f88eac48af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a011b78a17b1e0b8b7963d5f88eac48af">from_node</a> (const BasicNodeType &amp;n, CompatSeqType &amp;s) -&gt; decltype(n.template get_value&lt; typename CompatSeqType::value_type &gt;(), void())</td></tr>
<tr class="memdesc:a011b78a17b1e0b8b7963d5f88eac48af"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for container objects of only keys or values, e.g., std::vector or std::set, whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#a011b78a17b1e0b8b7963d5f88eac48af">More...</a><br /></td></tr>
<tr class="separator:a011b78a17b1e0b8b7963d5f88eac48af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4610f520dd0300959fbd5c94ccdcdc"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename SeqContainerAdapter , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, is_sequence_container_adapter&lt; SeqContainerAdapter &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adb4610f520dd0300959fbd5c94ccdcdc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#adb4610f520dd0300959fbd5c94ccdcdc">from_node</a> (const BasicNodeType &amp;n, SeqContainerAdapter &amp;ca) -&gt; decltype(n.template get_value&lt; typename SeqContainerAdapter::value_type &gt;(), ca.push(std::declval&lt; typename SeqContainerAdapter::value_type &gt;()), void())</td></tr>
<tr class="memdesc:adb4610f520dd0300959fbd5c94ccdcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for sequence container adapter objects, e.g., std::stack or std::queue, whose element type must be either a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#adb4610f520dd0300959fbd5c94ccdcdc">More...</a><br /></td></tr>
<tr class="separator:adb4610f520dd0300959fbd5c94ccdcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79df658bd9bd2fdf6909d0618a5ebafb"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename CompatMapType , enable_if_t&lt; is_constructible_mapping_type&lt; CompatMapType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a79df658bd9bd2fdf6909d0618a5ebafb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a79df658bd9bd2fdf6909d0618a5ebafb">from_node</a> (const BasicNodeType &amp;n, CompatMapType &amp;m) -&gt; decltype(std::declval&lt; const BasicNodeType &amp; &gt;() .template get_value&lt; typename CompatMapType::key_type &gt;(), std::declval&lt; const BasicNodeType &amp; &gt;() .template get_value&lt; typename CompatMapType::mapped_type &gt;(), m.emplace(std::declval&lt; typename CompatMapType::key_type &gt;(), std::declval&lt; typename CompatMapType::mapped_type &gt;()), void())</td></tr>
<tr class="memdesc:a79df658bd9bd2fdf6909d0618a5ebafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for mappings whose key and value are of both compatible types.  <a href="node_8hpp.html#a79df658bd9bd2fdf6909d0618a5ebafb">More...</a><br /></td></tr>
<tr class="separator:a79df658bd9bd2fdf6909d0618a5ebafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a48dfab59d6a36cbfe59a371c81a58"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a17a48dfab59d6a36cbfe59a371c81a58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a17a48dfab59d6a36cbfe59a371c81a58">from_node</a> (const BasicNodeType &amp;n, std::nullptr_t &amp;null)</td></tr>
<tr class="memdesc:a17a48dfab59d6a36cbfe59a371c81a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for nullptr.  <a href="node_8hpp.html#a17a48dfab59d6a36cbfe59a371c81a58">More...</a><br /></td></tr>
<tr class="separator:a17a48dfab59d6a36cbfe59a371c81a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea21001d797388e4a404f87084c2624"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5ea21001d797388e4a404f87084c2624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a5ea21001d797388e4a404f87084c2624">from_node</a> (const BasicNodeType &amp;n, bool &amp;b)</td></tr>
<tr class="memdesc:a5ea21001d797388e4a404f87084c2624"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for booleans.  <a href="node_8hpp.html#a5ea21001d797388e4a404f87084c2624">More...</a><br /></td></tr>
<tr class="separator:a5ea21001d797388e4a404f87084c2624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fca29e5a2225fd45d3044ff619b5d33"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename IntegerType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, is_non_bool_integral&lt; IntegerType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7fca29e5a2225fd45d3044ff619b5d33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a7fca29e5a2225fd45d3044ff619b5d33">from_node</a> (const BasicNodeType &amp;n, IntegerType &amp;i)</td></tr>
<tr class="memdesc:a7fca29e5a2225fd45d3044ff619b5d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for integers.  <a href="node_8hpp.html#a7fca29e5a2225fd45d3044ff619b5d33">More...</a><br /></td></tr>
<tr class="separator:a7fca29e5a2225fd45d3044ff619b5d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72213774bf1c36d073223360a89404c5"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename FloatType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_floating_point&lt; FloatType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a72213774bf1c36d073223360a89404c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a72213774bf1c36d073223360a89404c5">from_node</a> (const BasicNodeType &amp;n, FloatType &amp;f)</td></tr>
<tr class="memdesc:a72213774bf1c36d073223360a89404c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for floating point values.  <a href="node_8hpp.html#a72213774bf1c36d073223360a89404c5">More...</a><br /></td></tr>
<tr class="separator:a72213774bf1c36d073223360a89404c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb405949c717ffa8f81bfd67cf6d13f"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aecb405949c717ffa8f81bfd67cf6d13f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aecb405949c717ffa8f81bfd67cf6d13f">from_node</a> (const BasicNodeType &amp;n, typename BasicNodeType::string_type &amp;s)</td></tr>
<tr class="memdesc:aecb405949c717ffa8f81bfd67cf6d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for BasicNodeType::string_type objects.  <a href="node_8hpp.html#aecb405949c717ffa8f81bfd67cf6d13f">More...</a><br /></td></tr>
<tr class="separator:aecb405949c717ffa8f81bfd67cf6d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd049c3aaad326f4edde88c0d97f86d"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename CompatibleStringType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, negation&lt; std::is_same&lt; CompatibleStringType, typename BasicNodeType::string_type &gt;&gt;, disjunction&lt; std::is_constructible&lt; CompatibleStringType, const typename BasicNodeType::string_type &amp; &gt;, std::is_assignable&lt; CompatibleStringType, const typename BasicNodeType::string_type &amp; &gt;&gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:accd049c3aaad326f4edde88c0d97f86d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#accd049c3aaad326f4edde88c0d97f86d">from_node</a> (const BasicNodeType &amp;n, CompatibleStringType &amp;s)</td></tr>
<tr class="memdesc:accd049c3aaad326f4edde88c0d97f86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for compatible string type.  <a href="node_8hpp.html#accd049c3aaad326f4edde88c0d97f86d">More...</a><br /></td></tr>
<tr class="separator:accd049c3aaad326f4edde88c0d97f86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0dde966166084faa12789807edf923"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , typename U , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2f0dde966166084faa12789807edf923"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2f0dde966166084faa12789807edf923">from_node</a> (const BasicNodeType &amp;n, std::pair&lt; T, U &gt; &amp;p) -&gt; decltype(std::declval&lt; const BasicNodeType &amp; &gt;().template get_value&lt; T &gt;(), std::declval&lt; const BasicNodeType &amp; &gt;().template get_value&lt; U &gt;(), void())</td></tr>
<tr class="memdesc:a2f0dde966166084faa12789807edf923"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for std::pair objects whose element types must be either a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type.  <a href="node_8hpp.html#a2f0dde966166084faa12789807edf923">More...</a><br /></td></tr>
<tr class="separator:a2f0dde966166084faa12789807edf923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb467a36467945fd28bcd3a3dbc9edc2"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename... Types, std::size_t... Idx&gt; </td></tr>
<tr class="memitem:aeb467a36467945fd28bcd3a3dbc9edc2"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aeb467a36467945fd28bcd3a3dbc9edc2">from_node_tuple_impl</a> (const BasicNodeType &amp;n, <a class="el" href="node_8hpp.html#a961d746437c4b43a508e8841f4c5c6c4">index_sequence</a>&lt; Idx... &gt;)</td></tr>
<tr class="memdesc:aeb467a36467945fd28bcd3a3dbc9edc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">concrete implementation of from_node function for std::tuple objects.  <a href="node_8hpp.html#aeb467a36467945fd28bcd3a3dbc9edc2">More...</a><br /></td></tr>
<tr class="separator:aeb467a36467945fd28bcd3a3dbc9edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb5527cd21e5e57efdcbcb6d5de5750"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename... Types, enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0cb5527cd21e5e57efdcbcb6d5de5750"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a0cb5527cd21e5e57efdcbcb6d5de5750">from_node</a> (const BasicNodeType &amp;n, std::tuple&lt; Types... &gt; &amp;t)</td></tr>
<tr class="memdesc:a0cb5527cd21e5e57efdcbcb6d5de5750"><td class="mdescLeft">&#160;</td><td class="mdescRight">from_node function for std::tuple objects whose value types must all be either a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type  <a href="node_8hpp.html#a0cb5527cd21e5e57efdcbcb6d5de5750">More...</a><br /></td></tr>
<tr class="separator:a0cb5527cd21e5e57efdcbcb6d5de5750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3731d43aae60ea565195dc7d0722e1"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_same&lt; typename BasicNodeType::sequence_type, remove_cvref_t&lt; T &gt;&gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afb3731d43aae60ea565195dc7d0722e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#afb3731d43aae60ea565195dc7d0722e1">to_node</a> (BasicNodeType &amp;n, T &amp;&amp;s) noexcept</td></tr>
<tr class="memdesc:afb3731d43aae60ea565195dc7d0722e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_node function for BasicNodeType::sequence_type objects.  <a href="node_8hpp.html#afb3731d43aae60ea565195dc7d0722e1">More...</a><br /></td></tr>
<tr class="separator:afb3731d43aae60ea565195dc7d0722e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978ce708d868cad0027e88d327d860f4"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename NullType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_same&lt; NullType, std::nullptr_t &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a978ce708d868cad0027e88d327d860f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a978ce708d868cad0027e88d327d860f4">to_node</a> (BasicNodeType &amp;n, NullType)</td></tr>
<tr class="memdesc:a978ce708d868cad0027e88d327d860f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_node function for null objects.  <a href="node_8hpp.html#a978ce708d868cad0027e88d327d860f4">More...</a><br /></td></tr>
<tr class="separator:a978ce708d868cad0027e88d327d860f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad288e0c5537e9b214607569bab2614e1"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_same&lt; typename BasicNodeType::boolean_type, T &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad288e0c5537e9b214607569bab2614e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#ad288e0c5537e9b214607569bab2614e1">to_node</a> (BasicNodeType &amp;n, T b) noexcept</td></tr>
<tr class="memdesc:ad288e0c5537e9b214607569bab2614e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_node function for BasicNodeType::boolean_type objects.  <a href="node_8hpp.html#ad288e0c5537e9b214607569bab2614e1">More...</a><br /></td></tr>
<tr class="separator:ad288e0c5537e9b214607569bab2614e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb24307dc5efef0c8f2b52e57a986f6"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , typename T , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, negation&lt; is_null_pointer&lt; T &gt;&gt;, std::is_constructible&lt; typename BasicNodeType::string_type, const T &amp; &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2cb24307dc5efef0c8f2b52e57a986f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a2cb24307dc5efef0c8f2b52e57a986f6">to_node</a> (BasicNodeType &amp;n, const T &amp;s)</td></tr>
<tr class="memdesc:a2cb24307dc5efef0c8f2b52e57a986f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_node function for compatible strings.  <a href="node_8hpp.html#a2cb24307dc5efef0c8f2b52e57a986f6">More...</a><br /></td></tr>
<tr class="separator:a2cb24307dc5efef0c8f2b52e57a986f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7ae98d52265316a5c797c06b0cf994"><td class="memTemplParams" colspan="2">template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1f7ae98d52265316a5c797c06b0cf994"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a1f7ae98d52265316a5c797c06b0cf994">to_node</a> (BasicNodeType &amp;n, typename BasicNodeType::string_type &amp;&amp;s) noexcept</td></tr>
<tr class="memdesc:a1f7ae98d52265316a5c797c06b0cf994"><td class="mdescLeft">&#160;</td><td class="mdescRight">to_node function for rvalue string node values  <a href="node_8hpp.html#a1f7ae98d52265316a5c797c06b0cf994">More...</a><br /></td></tr>
<tr class="separator:a1f7ae98d52265316a5c797c06b0cf994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec92720797c84629d71585fb7fcc5bce"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename... &gt; class SequenceType, template&lt; typename, typename, typename... &gt; class MappingType, typename BooleanType , typename IntegerType , typename FloatNumberType , typename StringType , template&lt; typename, typename=void &gt; class ConverterType&gt; </td></tr>
<tr class="memitem:aec92720797c84629d71585fb7fcc5bce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aec92720797c84629d71585fb7fcc5bce">swap</a> (<a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;lhs, <a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;rhs) noexcept(noexcept(lhs.swap(rhs)))</td></tr>
<tr class="memdesc:aec92720797c84629d71585fb7fcc5bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap function for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> objects.  <a href="node_8hpp.html#aec92720797c84629d71585fb7fcc5bce">More...</a><br /></td></tr>
<tr class="separator:aec92720797c84629d71585fb7fcc5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2ca7a9017b457d014fdd166589175f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename... &gt; class SequenceType, template&lt; typename, typename, typename... &gt; class MappingType, typename BooleanType , typename IntegerType , typename FloatNumberType , typename StringType , template&lt; typename, typename=void &gt; class ConverterType&gt; </td></tr>
<tr class="memitem:a1e2ca7a9017b457d014fdd166589175f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#a1e2ca7a9017b457d014fdd166589175f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;n)</td></tr>
<tr class="memdesc:a1e2ca7a9017b457d014fdd166589175f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operator for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template class.  <a href="node_8hpp.html#a1e2ca7a9017b457d014fdd166589175f">More...</a><br /></td></tr>
<tr class="separator:a1e2ca7a9017b457d014fdd166589175f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91c8117a14a778eead725f90bcb6b3f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename... &gt; class SequenceType, template&lt; typename, typename, typename... &gt; class MappingType, typename BooleanType , typename IntegerType , typename FloatNumberType , typename StringType , template&lt; typename, typename=void &gt; class ConverterType&gt; </td></tr>
<tr class="memitem:aa91c8117a14a778eead725f90bcb6b3f"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="node_8hpp.html#aa91c8117a14a778eead725f90bcb6b3f">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;n)</td></tr>
<tr class="memdesc:aa91c8117a14a778eead725f90bcb6b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extraction operator for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template class.  <a href="node_8hpp.html#aa91c8117a14a778eead725f90bcb6b3f">More...</a><br /></td></tr>
<tr class="separator:aa91c8117a14a778eead725f90bcb6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8852a3ea30a1b2dcfa97ab7e521fb2e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a537684263bad4bb413d1fd068cd09609">fkyaml::node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliterals_1_1yaml__literals.html#a8852a3ea30a1b2dcfa97ab7e521fb2e3">literals::yaml_literals::operator&quot;&quot;_yaml</a> (const char *s, std::size_t n)</td></tr>
<tr class="memdesc:a8852a3ea30a1b2dcfa97ab7e521fb2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user-defined string literal which deserializes a <code>char</code> array into a <code>node</code> object.  <a href="namespaceliterals_1_1yaml__literals.html#a8852a3ea30a1b2dcfa97ab7e521fb2e3">More...</a><br /></td></tr>
<tr class="separator:a8852a3ea30a1b2dcfa97ab7e521fb2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3c20cfa28cac892aa747eb8ba1e939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a537684263bad4bb413d1fd068cd09609">fkyaml::node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliterals_1_1yaml__literals.html#a4a3c20cfa28cac892aa747eb8ba1e939">literals::yaml_literals::operator&quot;&quot;_yaml</a> (const char16_t *s, std::size_t n)</td></tr>
<tr class="memdesc:a4a3c20cfa28cac892aa747eb8ba1e939"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user-defined string literal which deserializes a <code>char16_t</code> array into a <code>node</code> object.  <a href="namespaceliterals_1_1yaml__literals.html#a4a3c20cfa28cac892aa747eb8ba1e939">More...</a><br /></td></tr>
<tr class="separator:a4a3c20cfa28cac892aa747eb8ba1e939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d61c4389dcf42218d44537cb1bbbd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_8hpp.html#a537684263bad4bb413d1fd068cd09609">fkyaml::node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceliterals_1_1yaml__literals.html#aa9d61c4389dcf42218d44537cb1bbbd5">literals::yaml_literals::operator&quot;&quot;_yaml</a> (const char32_t *s, std::size_t n)</td></tr>
<tr class="memdesc:aa9d61c4389dcf42218d44537cb1bbbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user-defined string literal which deserializes a <code>char32_t</code> array into a <code>node</code> object.  <a href="namespaceliterals_1_1yaml__literals.html#aa9d61c4389dcf42218d44537cb1bbbd5">More...</a><br /></td></tr>
<tr class="separator:aa9d61c4389dcf42218d44537cb1bbbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a28e7d5eedccb11d99bb66e3f30d159d1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html#a28e7d5eedccb11d99bb66e3f30d159d1">node_attr_mask::value</a> = 0x0000FFFFu</td></tr>
<tr class="memdesc:a28e7d5eedccb11d99bb66e3f30d159d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit mask for node value type bits.  <a href="namespacenode__attr__mask.html#a28e7d5eedccb11d99bb66e3f30d159d1">More...</a><br /></td></tr>
<tr class="separator:a28e7d5eedccb11d99bb66e3f30d159d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e89db767eda3624606c40ef62539dd7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html#a5e89db767eda3624606c40ef62539dd7">node_attr_mask::style</a> = 0x00FF0000u</td></tr>
<tr class="memdesc:a5e89db767eda3624606c40ef62539dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit mask for node style type bits. (bits are not yet defined.)  <a href="namespacenode__attr__mask.html#a5e89db767eda3624606c40ef62539dd7">More...</a><br /></td></tr>
<tr class="separator:a5e89db767eda3624606c40ef62539dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b96740838518baff91779d59315ede"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html#ad7b96740838518baff91779d59315ede">node_attr_mask::props</a> = 0xFF000000u</td></tr>
<tr class="memdesc:ad7b96740838518baff91779d59315ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit mask for node property related bits.  <a href="namespacenode__attr__mask.html#ad7b96740838518baff91779d59315ede">More...</a><br /></td></tr>
<tr class="separator:ad7b96740838518baff91779d59315ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6112d31d46c2fbfa26f74d0b8422bbe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html#ac6112d31d46c2fbfa26f74d0b8422bbe">node_attr_mask::anchoring</a> = 0x03000000u</td></tr>
<tr class="memdesc:ac6112d31d46c2fbfa26f74d0b8422bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit mask for anchor/alias node type bits.  <a href="namespacenode__attr__mask.html#ac6112d31d46c2fbfa26f74d0b8422bbe">More...</a><br /></td></tr>
<tr class="separator:ac6112d31d46c2fbfa26f74d0b8422bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaef22566f45c84bf213e69ddc8441df"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html#abaef22566f45c84bf213e69ddc8441df">node_attr_mask::anchor_offset</a> = 0xFC000000u</td></tr>
<tr class="memdesc:abaef22566f45c84bf213e69ddc8441df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit mask for anchor offset value bits.  <a href="namespacenode__attr__mask.html#abaef22566f45c84bf213e69ddc8441df">More...</a><br /></td></tr>
<tr class="separator:abaef22566f45c84bf213e69ddc8441df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75871817083d28aa9f55802c99cf0176"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__mask.html#a75871817083d28aa9f55802c99cf0176">node_attr_mask::all</a> = std::numeric_limits&lt;<a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&gt;::max()</td></tr>
<tr class="memdesc:a75871817083d28aa9f55802c99cf0176"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit mask for all the bits for node attributes.  <a href="namespacenode__attr__mask.html#a75871817083d28aa9f55802c99cf0176">More...</a><br /></td></tr>
<tr class="separator:a75871817083d28aa9f55802c99cf0176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd11cdb089b119eef03df923187c860"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a8dd11cdb089b119eef03df923187c860">node_attr_bits::seq_bit</a> = 1u &lt;&lt; 0</td></tr>
<tr class="memdesc:a8dd11cdb089b119eef03df923187c860"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequence node bit.  <a href="namespacenode__attr__bits.html#a8dd11cdb089b119eef03df923187c860">More...</a><br /></td></tr>
<tr class="separator:a8dd11cdb089b119eef03df923187c860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ee9a91310a3d32f6973225b57364b6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a07ee9a91310a3d32f6973225b57364b6">node_attr_bits::map_bit</a> = 1u &lt;&lt; 1</td></tr>
<tr class="memdesc:a07ee9a91310a3d32f6973225b57364b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mapping node bit.  <a href="namespacenode__attr__bits.html#a07ee9a91310a3d32f6973225b57364b6">More...</a><br /></td></tr>
<tr class="separator:a07ee9a91310a3d32f6973225b57364b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17be068e6290833d4d7892317217a460"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a17be068e6290833d4d7892317217a460">node_attr_bits::null_bit</a> = 1u &lt;&lt; 2</td></tr>
<tr class="memdesc:a17be068e6290833d4d7892317217a460"><td class="mdescLeft">&#160;</td><td class="mdescRight">The null scalar node bit.  <a href="namespacenode__attr__bits.html#a17be068e6290833d4d7892317217a460">More...</a><br /></td></tr>
<tr class="separator:a17be068e6290833d4d7892317217a460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46605ffa41339c3169e4e3891ca849c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#af46605ffa41339c3169e4e3891ca849c">node_attr_bits::bool_bit</a> = 1u &lt;&lt; 3</td></tr>
<tr class="memdesc:af46605ffa41339c3169e4e3891ca849c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean scalar node bit.  <a href="namespacenode__attr__bits.html#af46605ffa41339c3169e4e3891ca849c">More...</a><br /></td></tr>
<tr class="separator:af46605ffa41339c3169e4e3891ca849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df48f49b5bc2ec3686080cfe0ab41ff"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a7df48f49b5bc2ec3686080cfe0ab41ff">node_attr_bits::int_bit</a> = 1u &lt;&lt; 4</td></tr>
<tr class="memdesc:a7df48f49b5bc2ec3686080cfe0ab41ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer scalar node bit.  <a href="namespacenode__attr__bits.html#a7df48f49b5bc2ec3686080cfe0ab41ff">More...</a><br /></td></tr>
<tr class="separator:a7df48f49b5bc2ec3686080cfe0ab41ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa316aef76e2853e5691fa0ceae7f8e23"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#aa316aef76e2853e5691fa0ceae7f8e23">node_attr_bits::float_bit</a> = 1u &lt;&lt; 5</td></tr>
<tr class="memdesc:aa316aef76e2853e5691fa0ceae7f8e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The floating point scalar node bit.  <a href="namespacenode__attr__bits.html#aa316aef76e2853e5691fa0ceae7f8e23">More...</a><br /></td></tr>
<tr class="separator:aa316aef76e2853e5691fa0ceae7f8e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b3b6d4a14ed895ffc61954db9443ab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#ab4b3b6d4a14ed895ffc61954db9443ab">node_attr_bits::string_bit</a> = 1u &lt;&lt; 6</td></tr>
<tr class="memdesc:ab4b3b6d4a14ed895ffc61954db9443ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string scalar node bit.  <a href="namespacenode__attr__bits.html#ab4b3b6d4a14ed895ffc61954db9443ab">More...</a><br /></td></tr>
<tr class="separator:ab4b3b6d4a14ed895ffc61954db9443ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7884aab590c799079d2b2b95ff3f655"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#ae7884aab590c799079d2b2b95ff3f655">node_attr_bits::scalar_bits</a> = null_bit | bool_bit | int_bit | float_bit | string_bit</td></tr>
<tr class="memdesc:ae7884aab590c799079d2b2b95ff3f655"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility bit set to filter scalar node bits.  <a href="namespacenode__attr__bits.html#ae7884aab590c799079d2b2b95ff3f655">More...</a><br /></td></tr>
<tr class="separator:ae7884aab590c799079d2b2b95ff3f655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad231020aef8fac8d5a5400a91a18d704"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#ad231020aef8fac8d5a5400a91a18d704">node_attr_bits::anchor_bit</a> = 0x01000000u</td></tr>
<tr class="memdesc:ad231020aef8fac8d5a5400a91a18d704"><td class="mdescLeft">&#160;</td><td class="mdescRight">The anchor node bit.  <a href="namespacenode__attr__bits.html#ad231020aef8fac8d5a5400a91a18d704">More...</a><br /></td></tr>
<tr class="separator:ad231020aef8fac8d5a5400a91a18d704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f25187bb7d226f42488f3f7929d7da"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#ae4f25187bb7d226f42488f3f7929d7da">node_attr_bits::alias_bit</a> = 0x02000000u</td></tr>
<tr class="memdesc:ae4f25187bb7d226f42488f3f7929d7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias node bit.  <a href="namespacenode__attr__bits.html#ae4f25187bb7d226f42488f3f7929d7da">More...</a><br /></td></tr>
<tr class="separator:ae4f25187bb7d226f42488f3f7929d7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611299e36e785aea538d6bcfd4225d81"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenode__attr__bits.html#a611299e36e785aea538d6bcfd4225d81">node_attr_bits::default_bits</a> = null_bit</td></tr>
<tr class="memdesc:a611299e36e785aea538d6bcfd4225d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility bit set for initialization.  <a href="namespacenode__attr__bits.html#a611299e36e785aea538d6bcfd4225d81">More...</a><br /></td></tr>
<tr class="separator:a611299e36e785aea538d6bcfd4225d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3b92400c6d044c4267a7b329cbf778"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#a7b52f29237cf77b927dc7bf269451af7">FK_YAML_INLINE_VAR</a> const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFK__YAML__NAMESPACE__BEGIN.html#a5a3b92400c6d044c4267a7b329cbf778">FK_YAML_NAMESPACE_BEGIN::from_node</a></td></tr>
<tr class="memdesc:a5a3b92400c6d044c4267a7b329cbf778"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global object to represent ADL friendly from_node functor.  <a href="namespaceFK__YAML__NAMESPACE__BEGIN.html#a5a3b92400c6d044c4267a7b329cbf778">More...</a><br /></td></tr>
<tr class="separator:a5a3b92400c6d044c4267a7b329cbf778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc2f2a7c9e22d3c8ff0dddcc13f5320"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="node_8hpp.html#a7b52f29237cf77b927dc7bf269451af7">FK_YAML_INLINE_VAR</a> const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFK__YAML__NAMESPACE__BEGIN.html#afcc2f2a7c9e22d3c8ff0dddcc13f5320">FK_YAML_NAMESPACE_BEGIN::to_node</a> = detail::static_const&lt;detail::to_node_fn&gt;::value</td></tr>
<tr class="memdesc:afcc2f2a7c9e22d3c8ff0dddcc13f5320"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global object to represent ADL friendly to_node functor.  <a href="namespaceFK__YAML__NAMESPACE__BEGIN.html#afcc2f2a7c9e22d3c8ff0dddcc13f5320">More...</a><br /></td></tr>
<tr class="separator:afcc2f2a7c9e22d3c8ff0dddcc13f5320"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a31928ceeb5c5f5faeb6954e9c6593de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31928ceeb5c5f5faeb6954e9c6593de5">&#9670;&nbsp;</a></span>FK_YAML_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;assert(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a315ca62cbd45547de6f2cad2605ed96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315ca62cbd45547de6f2cad2605ed96b">&#9670;&nbsp;</a></span>FK_YAML_CONVERSIONS_SCALAR_CONV_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_CONVERSIONS_SCALAR_CONV_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e76ad840169843954dcdef9f88faabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e76ad840169843954dcdef9f88faabe">&#9670;&nbsp;</a></span>FK_YAML_CPLUSPLUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_CPLUSPLUS&#160;&#160;&#160;__cplusplus</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ed9f28c950a250f561972d09c175bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed9f28c950a250f561972d09c175bed">&#9670;&nbsp;</a></span>FK_YAML_CXX17_CONSTEXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_CXX17_CONSTEXPR</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f6d30daca2f760a949ea88dc5c0be7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6d30daca2f760a949ea88dc5c0be7b">&#9670;&nbsp;</a></span>FK_YAML_DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DEPRECATED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07a39c368eb10dd27014ce43d8f8c1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a39c368eb10dd27014ce43d8f8c1a0">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ASSERT_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ASSERT_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73fb059a0fa6820c9e6e9d763361a811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fb059a0fa6820c9e6e9d763361a811">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_CONVERSIONS_FROM_NODE_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_CONVERSIONS_FROM_NODE_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a903ec05a7fc82a2428429df8c5271aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903ec05a7fc82a2428429df8c5271aa8">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_CONVERSIONS_TO_NODE_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_CONVERSIONS_TO_NODE_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb418b84d5dfc8c760da80ac4acbe17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb418b84d5dfc8c760da80ac4acbe17a">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_CONVERSIONS_TO_STRING_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_CONVERSIONS_TO_STRING_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a550134396f4ee560420a5da216a3c6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550134396f4ee560420a5da216a3c6b7">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_DOCUMENT_METAINFO_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_DOCUMENT_METAINFO_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6128f597b980ad8c14791716b16f6905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6128f597b980ad8c14791716b16f6905">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ENCODINGS_URI_ENCODING_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ENCODINGS_URI_ENCODING_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c6678411ce2f413d10ab939fca4950e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6678411ce2f413d10ab939fca4950e">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ENCODINGS_UTF_ENCODE_DETECTOR_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ENCODINGS_UTF_ENCODE_DETECTOR_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf722435965e0efbb23fd6e9d75806a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf722435965e0efbb23fd6e9d75806a">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ENCODINGS_UTF_ENCODE_T_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ENCODINGS_UTF_ENCODE_T_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f616bba37f166a685652c7cb435367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f616bba37f166a685652c7cb435367">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ENCODINGS_UTF_ENCODINGS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ENCODINGS_UTF_ENCODINGS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ce5c06e4036c88b6f2bee7a659af147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce5c06e4036c88b6f2bee7a659af147">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ENCODINGS_YAML_ESCAPER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ENCODINGS_YAML_ESCAPER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a517cfa098a14dbb480f7daa8992f70a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517cfa098a14dbb480f7daa8992f70a5">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_BLOCK_SCALAR_HEADER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_BLOCK_SCALAR_HEADER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac7dc7dc73c20b60450c5e45c0d095fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7dc7dc73c20b60450c5e45c0d095fe">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_DESERIALIZER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_DESERIALIZER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e898263e01addd077817a0dee60f444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e898263e01addd077817a0dee60f444">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_INPUT_ADAPTER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_INPUT_ADAPTER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ee288e8b7b5d792eb26019e7028972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee288e8b7b5d792eb26019e7028972f">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_LEXICAL_ANALYZER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_LEXICAL_ANALYZER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6fc1005dcc5f39e8de8c29e1ad93aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fc1005dcc5f39e8de8c29e1ad93aa4">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_POSITION_TRACKER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_POSITION_TRACKER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9231e5620702ff02f316d9ab7e0c4237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9231e5620702ff02f316d9ab7e0c4237">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_SCALAR_PARSER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_SCALAR_PARSER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2229ba9eb449979c3469671ba139ba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2229ba9eb449979c3469671ba139ba5a">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_SCALAR_SCANNER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_SCALAR_SCANNER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a494fc1ebde74204108a8ca6a50049634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494fc1ebde74204108a8ca6a50049634">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_TAG_RESOLVER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_TAG_RESOLVER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace7eaf3b7c95ae119e3ff84b92406f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7eaf3b7c95ae119e3ff84b92406f6f">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_INPUT_TAG_T_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_INPUT_TAG_T_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9575789661c871a7cf91ad56b0ea4778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9575789661c871a7cf91ad56b0ea4778">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_ITERATOR_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_ITERATOR_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eca7bf775d1a5e4d3c8ad880d7d832e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca7bf775d1a5e4d3c8ad880d7d832e">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_MACROS_CPP_CONFIG_MACROS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_MACROS_CPP_CONFIG_MACROS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4ffd8ee169edc42f216c02f1bb38c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ffd8ee169edc42f216c02f1bb38c7b">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_MACROS_DEFINE_MACROS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_MACROS_DEFINE_MACROS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08e0e604d41150b1e67ca46892712dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e0e604d41150b1e67ca46892712dc1">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_META_DETECT_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_META_DETECT_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f87ef55820cf1915d8092b5ad2ec182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f87ef55820cf1915d8092b5ad2ec182">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_META_INPUT_ADAPTER_TRAITS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_META_INPUT_ADAPTER_TRAITS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48827bac72ca15afcf930e9c7df98d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48827bac72ca15afcf930e9c7df98d4d">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_META_NODE_TRAITS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_META_NODE_TRAITS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8801f8388f1fe5747182e8b93f5884d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8801f8388f1fe5747182e8b93f5884d">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_META_STL_SUPPLEMENT_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_META_STL_SUPPLEMENT_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a087aea18ba799c7628d26120ffe4fd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087aea18ba799c7628d26120ffe4fd5b">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_META_TYPE_TRAITS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_META_TYPE_TRAITS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8205dbc6a1114becc668105819ea1b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8205dbc6a1114becc668105819ea1b57">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_NAMESPACE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_NAMESPACE_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    FK_YAML_NAMESPACE_BEGIN                                                                        \</div>
<div class="line">    namespace detail                                                                               \</div>
<div class="line">    {</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8cc808373a7ff2e6615c65c32675dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cc808373a7ff2e6615c65c32675dd7">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_NAMESPACE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_NAMESPACE_END</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    } <span class="comment">/* namespace detail */</span>                                                                       \</div>
<div class="line">    FK_YAML_NAMESPACE_END</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2cd2f459bbe8d251d129a7e90d80b39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd2f459bbe8d251d129a7e90d80b39f">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_NODE_ATTRS_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_NODE_ATTRS_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40079b7d8557ed5715105f51e0fc79bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40079b7d8557ed5715105f51e0fc79bf">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_NODE_PROPERTY_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_NODE_PROPERTY_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acfcb54d961ccf200d835b1aa663c2eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcb54d961ccf200d835b1aa663c2eed">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_NODE_REF_STORAGE_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_NODE_REF_STORAGE_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ccb6e99c83db2575b974ed5629d64d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccb6e99c83db2575b974ed5629d64d1">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_OUTPUT_SERIALIZER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_OUTPUT_SERIALIZER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c8bb7ba3a320d8ac631b02acf395d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8bb7ba3a320d8ac631b02acf395d94">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_REVERSE_ITERATOR_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_REVERSE_ITERATOR_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a521ec30a3d8b7ba2d97fbb32ed571a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521ec30a3d8b7ba2d97fbb32ed571a4b">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_STR_VIEW_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_STR_VIEW_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e070a7e65cc31352a463f6f867ecb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e070a7e65cc31352a463f6f867ecb4">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_STRING_FORMATTER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_STRING_FORMATTER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5b5f982720d59454a6c85123b7a7597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b5f982720d59454a6c85123b7a7597">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_TYPES_LEXICAL_TOKEN_T_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_TYPES_LEXICAL_TOKEN_T_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe061b5111fc7195ef17d9edca4f5b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe061b5111fc7195ef17d9edca4f5b84">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_TYPES_NODE_T_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_TYPES_NODE_T_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae638cb73c78e8fd3696e86a5e7304d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae638cb73c78e8fd3696e86a5e7304d98">&#9670;&nbsp;</a></span>FK_YAML_DETAIL_TYPES_YAML_VERSION_T_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_DETAIL_TYPES_YAML_VERSION_T_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2a92fe80f3698335a9fe2691307053e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a92fe80f3698335a9fe2691307053e">&#9670;&nbsp;</a></span>FK_YAML_EXCEPTION_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_EXCEPTION_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5496e0cab9870aae8817553992dd331f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5496e0cab9870aae8817553992dd331f">&#9670;&nbsp;</a></span>FK_YAML_FKYAML_FWD_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_FKYAML_FWD_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62e750af2d337c30f39c9ad0d2dcb062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e750af2d337c30f39c9ad0d2dcb062">&#9670;&nbsp;</a></span>FK_YAML_HAS_BUILTIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_BUILTIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">builtin</td><td>)</td>
          <td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1e77145c4ee6f371568de3f4cfb58fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e77145c4ee6f371568de3f4cfb58fb">&#9670;&nbsp;</a></span>FK_YAML_HAS_CHAR8_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_CHAR8_T&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8130f3581afd8e031d89202a91de0629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8130f3581afd8e031d89202a91de0629">&#9670;&nbsp;</a></span>FK_YAML_HAS_CPP_ATTRIBUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_CPP_ATTRIBUTE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attr</td><td>)</td>
          <td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac02d604133d06d895b6be060c6a5c573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02d604133d06d895b6be060c6a5c573">&#9670;&nbsp;</a></span>FK_YAML_HAS_CXX_11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_CXX_11</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82f46236f82eff7e056e6effc1611835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f46236f82eff7e056e6effc1611835">&#9670;&nbsp;</a></span>FK_YAML_HAS_FEATURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_FEATURE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">feat</td><td>)</td>
          <td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f65d21181b09aefabe705743cef62d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f65d21181b09aefabe705743cef62d7">&#9670;&nbsp;</a></span>FK_YAML_HAS_INCLUDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_INCLUDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">header</td><td>)</td>
          <td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b6c747235e44832a32e96165a590cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b6c747235e44832a32e96165a590cb">&#9670;&nbsp;</a></span>FK_YAML_HAS_TO_CHARS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_HAS_TO_CHARS&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b52f29237cf77b927dc7bf269451af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b52f29237cf77b927dc7bf269451af7">&#9670;&nbsp;</a></span>FK_YAML_INLINE_VAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_INLINE_VAR</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a249b991273e00aaaf85a650f27249a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249b991273e00aaaf85a650f27249a7a">&#9670;&nbsp;</a></span>FK_YAML_LIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_LIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;(!!(expr))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed32bd89469f4d21c446553b092a78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed32bd89469f4d21c446553b092a78e5">&#9670;&nbsp;</a></span>FK_YAML_MAJOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_MAJOR_VERSION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb100a406a4a974beeecb7c431d2cac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb100a406a4a974beeecb7c431d2cac2">&#9670;&nbsp;</a></span>FK_YAML_MINOR_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_MINOR_VERSION&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185a20e9f9bea81c796ff61a9e309c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185a20e9f9bea81c796ff61a9e309c00">&#9670;&nbsp;</a></span>FK_YAML_NAMESPACE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NAMESPACE_BEGIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>fkyaml                                                                               \</div>
<div class="line">    {                                                                                              \</div>
<div class="line">    inline <span class="keyword">namespace </span><a class="code" href="node_8hpp.html#a099a14ffcb6ddf32b10ef261ac0da560">FK_YAML_NAMESPACE_VERSION</a>                                                     \</div>
<div class="line">    {</div>
<div class="ttc" id="anode_8hpp_html_a099a14ffcb6ddf32b10ef261ac0da560"><div class="ttname"><a href="node_8hpp.html#a099a14ffcb6ddf32b10ef261ac0da560">FK_YAML_NAMESPACE_VERSION</a></div><div class="ttdeci">#define FK_YAML_NAMESPACE_VERSION</div><div class="ttdef"><b>Definition:</b> node.hpp:65</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea705788534510a0a7d79fd1f1fa71ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea705788534510a0a7d79fd1f1fa71ce">&#9670;&nbsp;</a></span>FK_YAML_NAMESPACE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NAMESPACE_END</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    } <span class="comment">/* inline namespace FK_YAML_NAMESPACE_VERSION */</span>                                             \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a099a14ffcb6ddf32b10ef261ac0da560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099a14ffcb6ddf32b10ef261ac0da560">&#9670;&nbsp;</a></span>FK_YAML_NAMESPACE_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NAMESPACE_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="node_8hpp.html#abef760f14cd22ab6cb13697ac19aae2d">FK_YAML_NAMESPACE_VERSION_CONCAT</a>(<a class="code" href="node_8hpp.html#aed32bd89469f4d21c446553b092a78e5">FK_YAML_MAJOR_VERSION</a>, <a class="code" href="node_8hpp.html#acb100a406a4a974beeecb7c431d2cac2">FK_YAML_MINOR_VERSION</a>,                 \</div>
<div class="line">                                     <a class="code" href="node_8hpp.html#afa1473de0e2f8a700ef6521996fddf6d">FK_YAML_PATCH_VERSION</a>)</div>
<div class="ttc" id="anode_8hpp_html_abef760f14cd22ab6cb13697ac19aae2d"><div class="ttname"><a href="node_8hpp.html#abef760f14cd22ab6cb13697ac19aae2d">FK_YAML_NAMESPACE_VERSION_CONCAT</a></div><div class="ttdeci">#define FK_YAML_NAMESPACE_VERSION_CONCAT(major, minor, patch)</div><div class="ttdef"><b>Definition:</b> node.hpp:62</div></div>
<div class="ttc" id="anode_8hpp_html_acb100a406a4a974beeecb7c431d2cac2"><div class="ttname"><a href="node_8hpp.html#acb100a406a4a974beeecb7c431d2cac2">FK_YAML_MINOR_VERSION</a></div><div class="ttdeci">#define FK_YAML_MINOR_VERSION</div><div class="ttdef"><b>Definition:</b> node.hpp:57</div></div>
<div class="ttc" id="anode_8hpp_html_aed32bd89469f4d21c446553b092a78e5"><div class="ttname"><a href="node_8hpp.html#aed32bd89469f4d21c446553b092a78e5">FK_YAML_MAJOR_VERSION</a></div><div class="ttdeci">#define FK_YAML_MAJOR_VERSION</div><div class="ttdef"><b>Definition:</b> node.hpp:56</div></div>
<div class="ttc" id="anode_8hpp_html_afa1473de0e2f8a700ef6521996fddf6d"><div class="ttname"><a href="node_8hpp.html#afa1473de0e2f8a700ef6521996fddf6d">FK_YAML_PATCH_VERSION</a></div><div class="ttdeci">#define FK_YAML_PATCH_VERSION</div><div class="ttdef"><b>Definition:</b> node.hpp:58</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abef760f14cd22ab6cb13697ac19aae2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef760f14cd22ab6cb13697ac19aae2d">&#9670;&nbsp;</a></span>FK_YAML_NAMESPACE_VERSION_CONCAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NAMESPACE_VERSION_CONCAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">major, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">patch&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="node_8hpp.html#a67d0af4b89c59187056fd5397750ab46">FK_YAML_NAMESPACE_VERSION_CONCAT_IMPL</a>(major, minor, patch)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67d0af4b89c59187056fd5397750ab46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d0af4b89c59187056fd5397750ab46">&#9670;&nbsp;</a></span>FK_YAML_NAMESPACE_VERSION_CONCAT_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NAMESPACE_VERSION_CONCAT_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">major, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">patch&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;v##major##_##minor##_##patch</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc9c79e8d5ad55b8a634953a9e50f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9c79e8d5ad55b8a634953a9e50f741">&#9670;&nbsp;</a></span>FK_YAML_NO_SANITIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NO_SANITIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeafd9fee79fab98bf86a0cffb506ed6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafd9fee79fab98bf86a0cffb506ed6a">&#9670;&nbsp;</a></span>FK_YAML_NODE_TYPE_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NODE_TYPE_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d63ae2fec31f8307e150311aa07be01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d63ae2fec31f8307e150311aa07be01">&#9670;&nbsp;</a></span>FK_YAML_NODE_VALUE_CONVERTER_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_NODE_VALUE_CONVERTER_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd1af9ddb0c5a60ede41fe1a88932704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1af9ddb0c5a60ede41fe1a88932704">&#9670;&nbsp;</a></span>FK_YAML_ORDERED_MAP_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_ORDERED_MAP_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa1473de0e2f8a700ef6521996fddf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1473de0e2f8a700ef6521996fddf6d">&#9670;&nbsp;</a></span>FK_YAML_PATCH_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_PATCH_VERSION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb2c2dbdfbff0a11c6f4ad6418e8c2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2c2dbdfbff0a11c6f4ad6418e8c2a4">&#9670;&nbsp;</a></span>FK_YAML_UNLIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_UNLIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;(!!(expr))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f7ba7a72bef1bb2ed457b35c954eb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7ba7a72bef1bb2ed457b35c954eb59">&#9670;&nbsp;</a></span>FK_YAML_YAML_VERSION_TYPE_HPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FK_YAML_YAML_VERSION_TYPE_HPP</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4d53001e66630d08082e94939d47d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d53001e66630d08082e94939d47d8d7">&#9670;&nbsp;</a></span>add_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a4d53001e66630d08082e94939d47d8d7">add_pointer_t</a> =  typename std::add_pointer&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias template for std::add_pointer::type with C++11. </p>
<dl class="section note"><dt>Note</dt><dd>std::add_pointer_t is available since C++14. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/add_pointer">https://en.cppreference.com/w/cpp/types/add_pointer</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type to be added a pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54cc2298319894aeb38111302940516c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cc2298319894aeb38111302940516c">&#9670;&nbsp;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Val&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a54cc2298319894aeb38111302940516c">bool_constant</a> =  std::integral_constant&lt;bool, Val&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple implementation to use std::bool_constant with C++11/C++14. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Val</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a539f233efc15f8dee586f0ebc829bdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539f233efc15f8dee586f0ebc829bdf4">&#9670;&nbsp;</a></span>detected_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a539f233efc15f8dee586f0ebc829bdf4">detected_t</a> =  typename <a class="el" href="structdetector__impl_1_1detector.html">detector_impl::detector</a>&lt;<a class="el" href="structnonesuch.html">nonesuch</a>, void, Op, Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type traits to represent a detected type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>A type for desired operation type. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types passed to desired operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7686f4990569708f40dfde235b6c3b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7686f4990569708f40dfde235b6c3b11">&#9670;&nbsp;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Condition, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">enable_if_t</a> =  typename std::enable_if&lt;Condition, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias template for std::enable_if::type with C++11. </p>
<dl class="section note"><dt>Note</dt><dd>std::enable_if_t is available since C++14. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/enable_if">https://en.cppreference.com/w/cpp/types/enable_if</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Condition</td><td>A condition tested at compile time. </td></tr>
    <tr><td class="paramname">T</td><td>The type defined only if Condition is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48edf3cb86a41f7cbe08cbf7a59c33f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48edf3cb86a41f7cbe08cbf7a59c33f2">&#9670;&nbsp;</a></span>from_node_function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a48edf3cb86a41f7cbe08cbf7a59c33f2">from_node_function_t</a> =  decltype(<a class="el" href="node_8hpp.html#a0cb5527cd21e5e57efdcbcb6d5de5750">T::from_node</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type represent from_node function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type which provides from_node function. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types passed to from_node function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b738785a0eb6b59b96ad9c371db5680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b738785a0eb6b59b96ad9c371db5680">&#9670;&nbsp;</a></span>get_buffer_view_fn_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a2b738785a0eb6b59b96ad9c371db5680">get_buffer_view_fn_t</a> =  decltype(std::declval&lt;T&gt;().get_buffer_view())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type which represents get_buffer_view function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A target type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83ae1331bcc376fb9bd8c6d3c64416ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ae1331bcc376fb9bd8c6d3c64416ca">&#9670;&nbsp;</a></span>head_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a83ae1331bcc376fb9bd8c6d3c64416ca">head_type</a> =  typename <a class="el" href="structget__head__type.html">get_head_type</a>&lt;Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias template to retrieve the first type in variadic template arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Types of variadic template arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a961d746437c4b43a508e8841f4c5c6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961d746437c4b43a508e8841f4c5c6c4">&#9670;&nbsp;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Idx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a961d746437c4b43a508e8841f4c5c6c4">index_sequence</a> =  <a class="el" href="structinteger__sequence.html">integer_sequence</a>&lt;std::size_t, Idx...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b762cc05183be4d9e4f4f271add4c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b762cc05183be4d9e4f4f271add4c1e">&#9670;&nbsp;</a></span>index_sequence_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a7b762cc05183be4d9e4f4f271add4c1e">index_sequence_for</a> =  <a class="el" href="node_8hpp.html#a656800682289b17d905c9d5c4826b798">make_index_sequence</a>&lt;sizeof...(Types)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2004f373c1cccbd777a968a2da335c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2004f373c1cccbd777a968a2da335c8">&#9670;&nbsp;</a></span>is_all_signed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#aa2004f373c1cccbd777a968a2da335c8">is_all_signed</a> =  <a class="el" href="structconjunction.html">conjunction</a>&lt;std::is_signed&lt;Types&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type traits to check if Types are all signed arithmetic types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Types to check if they are all signed arithmetic types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeda646dae91776c1a743caa0997d3453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda646dae91776c1a743caa0997d3453">&#9670;&nbsp;</a></span>is_all_unsigned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#aeda646dae91776c1a743caa0997d3453">is_all_unsigned</a> =  <a class="el" href="structconjunction.html">conjunction</a>&lt;std::is_unsigned&lt;Types&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type traits to check if Types are all unsigned arithmetic types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Types to check if they are all unsigned arithmetic types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43a92b1246481aaae75580bc46c17ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43a92b1246481aaae75580bc46c17ea">&#9670;&nbsp;</a></span>is_constructible_mapping_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#ad43a92b1246481aaae75580bc46c17ea">is_constructible_mapping_type</a> =  <a class="el" href="structconjunction.html">conjunction</a>&lt;<a class="el" href="namespacedetect.html#affb3a084fde4974f3064ce9e9f0e1665">detect::has_key_type</a>&lt;T&gt;, <a class="el" href="namespacedetect.html#ab5db101970db1faec2887b4857f89b54">detect::has_mapped_type</a>&lt;T&gt;, <a class="el" href="namespacedetect.html#a5773069cbdb23777e6310c7d510445f9">detect::has_value_type</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility traits type alias to detect constructible associative container types from a mapping node, e.g., std::map or std::unordered_map. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A target type for detection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3056256dab12fe1854bb1225aa4a6fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3056256dab12fe1854bb1225aa4a6fda">&#9670;&nbsp;</a></span>is_constructible_sequence_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a3056256dab12fe1854bb1225aa4a6fda">is_constructible_sequence_type</a> =  <a class="el" href="structconjunction.html">conjunction</a>&lt;<a class="el" href="structnegation.html">negation</a>&lt;<a class="el" href="structis__basic__node.html">is_basic_node</a>&lt;T&gt; &gt;, <a class="el" href="namespacedetect.html#afed08d4544a75e5712c1aa976a2e8c2e">detect::has_iterator</a>&lt;T&gt;, <a class="el" href="structdetect_1_1is__iterator__traits.html">detect::is_iterator_traits</a>&lt;typename T::iterator&gt;, <a class="el" href="structdetect_1_1has__begin__end.html">detect::has_begin_end</a>&lt;T&gt;, <a class="el" href="structnegation.html">negation</a>&lt;std::is_same&lt;T, typename BasicNodeType::mapping_type&gt; &gt;, <a class="el" href="structnegation.html">negation</a>&lt;<a class="el" href="node_8hpp.html#ad43a92b1246481aaae75580bc46c17ea">is_constructible_mapping_type</a>&lt;T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility traits type alias to detect constructible container types from a sequence node, e.g., std::vector or std::list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>A target type for detection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59350837add49f0168ac942d20bbd3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59350837add49f0168ac942d20bbd3b6">&#9670;&nbsp;</a></span>is_detected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a59350837add49f0168ac942d20bbd3b6">is_detected</a> =  <a class="el" href="structdetector__impl_1_1detector.html">detector_impl::detector</a>&lt;<a class="el" href="structnonesuch.html">nonesuch</a>, void, Op, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type traits to detect Op operation with Args argument types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>A desired operation type. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types passed to desired operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54efded7d5471a1b8d88f5c2422a767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54efded7d5471a1b8d88f5c2422a767e">&#9670;&nbsp;</a></span>is_detected_exact</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a54efded7d5471a1b8d88f5c2422a767e">is_detected_exact</a> =  std::is_same&lt;Expected, <a class="el" href="node_8hpp.html#a539f233efc15f8dee586f0ebc829bdf4">detected_t</a>&lt;Op, Args...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type traits to check if Expected and a detected type are exactly the same. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Expected</td><td>An expected detection result type. </td></tr>
    <tr><td class="paramname">Op</td><td>A type for desired operation. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types passed to desired operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a790578ac5b9452db0206e4caa96ea99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790578ac5b9452db0206e4caa96ea99d">&#9670;&nbsp;</a></span>is_iterator_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItrType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a790578ac5b9452db0206e4caa96ea99d">is_iterator_of</a> =  std::is_same&lt;<a class="el" href="node_8hpp.html#a92dc8767e0b0b9b6022f61cb5b52278f">remove_cv_t</a>&lt;typename std::iterator_traits&lt;ItrType&gt;::value_type&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility alias to test if the value type of <code>ItrType</code> is <code>T</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ItrType</td><td>An iterator type. </td></tr>
    <tr><td class="paramname">T</td><td>The target iterator value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e968d716ada1ed7a862e4b814c8160d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e968d716ada1ed7a862e4b814c8160d">&#9670;&nbsp;</a></span>is_sequence_container_adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a4e968d716ada1ed7a862e4b814c8160d">is_sequence_container_adapter</a> =  <a class="el" href="structconjunction.html">conjunction</a>&lt;<a class="el" href="structnegation.html">negation</a>&lt;<a class="el" href="structis__basic__node.html">is_basic_node</a>&lt;T&gt; &gt;, <a class="el" href="namespacedetect.html#acfb7e3d7d6761807e13d9ba9df2bf73f">detect::has_container_type</a>&lt;T&gt;, <a class="el" href="namespacedetect.html#a5773069cbdb23777e6310c7d510445f9">detect::has_value_type</a>&lt;T&gt;, <a class="el" href="structnegation.html">negation</a>&lt;<a class="el" href="namespacedetect.html#affb3a084fde4974f3064ce9e9f0e1665">detect::has_key_type</a>&lt;T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility traits type alias to detect a sequence container adapter type, e.g., std::stack or std::queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A target type for detection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa20eda759366a68f17a54f537ae8047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa20eda759366a68f17a54f537ae8047">&#9670;&nbsp;</a></span>is_usable_as_key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparator , typename ObjectKeyType , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#aaa20eda759366a68f17a54f537ae8047">is_usable_as_key_type</a> =  typename std::conditional&lt;<a class="el" href="structis__comparable.html">is_comparable</a>&lt;Comparator, ObjectKeyType, KeyType&gt;::value, std::true_type, std::false_type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to check if KeyType can be used as key type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Comparator</td><td>An object type to compare T and U objects. </td></tr>
    <tr><td class="paramname">ObjectKeyType</td><td>The original key type. </td></tr>
    <tr><td class="paramname">KeyType</td><td>A type to be used as key type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a656800682289b17d905c9d5c4826b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656800682289b17d905c9d5c4826b798">&#9670;&nbsp;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Num&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a656800682289b17d905c9d5c4826b798">make_index_sequence</a> =  <a class="el" href="node_8hpp.html#a75f3ba12ebeca36c1c8225bdc6359256">make_integer_sequence</a>&lt;std::size_t, Num&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75f3ba12ebeca36c1c8225bdc6359256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f3ba12ebeca36c1c8225bdc6359256">&#9670;&nbsp;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T Num&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a75f3ba12ebeca36c1c8225bdc6359256">make_integer_sequence</a> =  typename <a class="el" href="structmake__int__seq__impl_1_1generator.html">make_int_seq_impl::generator</a>&lt;T, Num&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a537684263bad4bb413d1fd068cd09609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537684263bad4bb413d1fd068cd09609">&#9670;&nbsp;</a></span>node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="fkyaml__fwd_8hpp.html#a537684263bad4bb413d1fd068cd09609">node</a> =  <a class="el" href="classbasic__node.html">basic_node</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default YAML node value container. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://fktn-k.github.io/fkYAML/api/basic_node/node/">https://fktn-k.github.io/fkYAML/api/basic_node/node/</a> </dd></dl>

</div>
</div>
<a id="ab6227d2a40d02dbdbb471dfe9a74b3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6227d2a40d02dbdbb471dfe9a74b3a8">&#9670;&nbsp;</a></span>node_attr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#ab6227d2a40d02dbdbb471dfe9a74b3a8">node_attr_t</a> =  uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for node attribute bits. </p>

</div>
</div>
<a id="a92dc8767e0b0b9b6022f61cb5b52278f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dc8767e0b0b9b6022f61cb5b52278f">&#9670;&nbsp;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a92dc8767e0b0b9b6022f61cb5b52278f">remove_cv_t</a> =  typename std::remove_cv&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias template for std::remove_cv::type with C++11. </p>
<dl class="section note"><dt>Note</dt><dd>std::remove_cv_t is available since C++14. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/remove_cv">https://en.cppreference.com/w/cpp/types/remove_cv</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type from which const-volatile qualifiers are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51409636427db2734c1d4d0cbd00dd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51409636427db2734c1d4d0cbd00dd42">&#9670;&nbsp;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a51409636427db2734c1d4d0cbd00dd42">remove_cvref_t</a> =  typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple implementation to use std::remove_cvref_t with C++11/C++14/C++17. </p>
<dl class="section note"><dt>Note</dt><dd>std::remove_cvref &amp; std::remove_cvref_t are available since C++20. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/remove_cvref">https://en.cppreference.com/w/cpp/types/remove_cvref</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type from which cv-qualifiers and reference are removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add6d01d5cd2bed140c973e49eaced167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6d01d5cd2bed140c973e49eaced167">&#9670;&nbsp;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#add6d01d5cd2bed140c973e49eaced167">remove_pointer_t</a> =  typename std::remove_pointer&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias template for std::remove_pointer::type with C++11. </p>
<dl class="section note"><dt>Note</dt><dd>std::remove_pointer_t is available since C++14. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/remove_pointer">https://en.cppreference.com/w/cpp/types/remove_pointer</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type from which a pointer is removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a08cea569e6926ac8d7d74dd7178b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a08cea569e6926ac8d7d74dd7178b5f">&#9670;&nbsp;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a3a08cea569e6926ac8d7d74dd7178b5f">remove_reference_t</a> =  typename std::remove_reference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias template for std::remove_reference::type with C++11. </p>
<dl class="section note"><dt>Note</dt><dd>std::remove_reference_t is available since C++14. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/remove_reference">https://en.cppreference.com/w/cpp/types/remove_reference</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type from which a reference is removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16c4ce5b7369228779637c6bc99e548d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c4ce5b7369228779637c6bc99e548d">&#9670;&nbsp;</a></span>str_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#a16c4ce5b7369228779637c6bc99e548d">str_view</a> =  <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view into <code>char</code> sequence. </p>

</div>
</div>
<a id="ae1a047506a991ff456242540ea71f0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a047506a991ff456242540ea71f0f2">&#9670;&nbsp;</a></span>to_node_function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#ae1a047506a991ff456242540ea71f0f2">to_node_function_t</a> =  decltype(<a class="el" href="node_8hpp.html#a1f7ae98d52265316a5c797c06b0cf994">T::to_node</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type which represent to_node function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type which provides to_node function. </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types passed to to_node function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff50d00ebb4915d58c6d7f17be493431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff50d00ebb4915d58c6d7f17be493431">&#9670;&nbsp;</a></span>u16str_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#aff50d00ebb4915d58c6d7f17be493431">u16str_view</a> =  <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt;char16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view into <code>char16_t</code> sequence. </p>

</div>
</div>
<a id="af62f61f437c1cefdc65e3edf7a8c24a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62f61f437c1cefdc65e3edf7a8c24a9">&#9670;&nbsp;</a></span>u32str_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#af62f61f437c1cefdc65e3edf7a8c24a9">u32str_view</a> =  <a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt;char32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>view into <code>char32_t</code> sequence. </p>

</div>
</div>
<a id="aea2b02141ca4d395e98e45d91cc38c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2b02141ca4d395e98e45d91cc38c38">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="node_8hpp.html#aea2b02141ca4d395e98e45d91cc38c38">void_t</a> =  typename <a class="el" href="structmake__void.html">make_void</a>&lt;Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple implementation to use std::void_t with C++11/C++14. </p>
<dl class="section note"><dt>Note</dt><dd>std::void_t is available since C++17. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/types/void_t">https://en.cppreference.com/w/cpp/types/void_t</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Any types to be transformed to void type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a49eeff8a1d87cb6461bcb77d17e90f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49eeff8a1d87cb6461bcb77d17e90f0b">&#9670;&nbsp;</a></span>chomping_indicator_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a49eeff8a1d87cb6461bcb77d17e90f0b">chomping_indicator_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of chomping indicator types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a49eeff8a1d87cb6461bcb77d17e90f0ba6989032db1002ec3fb0b2de2c970f184"></a>STRIP&#160;</td><td class="fielddoc"><p>excludes final line breaks and trailing empty lines indicated by <code>-</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a49eeff8a1d87cb6461bcb77d17e90f0ba960f0b6c4711bd0a42965edec68192d8"></a>CLIP&#160;</td><td class="fielddoc"><p>preserves final line breaks but excludes trailing empty lines. </p>
<p>no indicator means this type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a49eeff8a1d87cb6461bcb77d17e90f0ba60cba2874369bd3790e14ea5f8a7bc58"></a>KEEP&#160;</td><td class="fielddoc"><p>preserves final line breaks and trailing empty lines indicated by <code>+</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="acb8c614d98ee86254fb432b2f82e7ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8c614d98ee86254fb432b2f82e7ebb">&#9670;&nbsp;</a></span>iterator_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#acb8c614d98ee86254fb432b2f82e7ebb">iterator_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definitions of iterator types for iterators internally held. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acb8c614d98ee86254fb432b2f82e7ebba2cb198a10d0a4c217ff4c15e98a97215"></a>SEQUENCE&#160;</td><td class="fielddoc"><p>sequence iterator type. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb8c614d98ee86254fb432b2f82e7ebba2fa399f11879d3347f324fe703fb9f97"></a>MAPPING&#160;</td><td class="fielddoc"><p>mapping iterator type. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5ceb55f511a84f394fedd24623b92da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceb55f511a84f394fedd24623b92da7">&#9670;&nbsp;</a></span>lexical_token_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a5ceb55f511a84f394fedd24623b92da7">lexical_token_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of lexical token types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a8ccd9703eee6b8fb515999099ea7ec4f"></a>END_OF_BUFFER&#160;</td><td class="fielddoc"><p>the end of input buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a395c63e6ab17238cee38c76ef808861d"></a>EXPLICIT_KEY_PREFIX&#160;</td><td class="fielddoc"><p>the character for explicit mapping key prefix <code>?</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a6ce05721da7b96323d74b4adcfbf9d8c"></a>KEY_SEPARATOR&#160;</td><td class="fielddoc"><p>the key separator <code>:</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a752a169eae200e7303f0e5fa443c3b13"></a>VALUE_SEPARATOR&#160;</td><td class="fielddoc"><p>the value separator <code>,</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a45ffec46a1c7e2801eb9f86516ddb8eb"></a>ANCHOR_PREFIX&#160;</td><td class="fielddoc"><p>the character for anchor prefix <code>&amp;</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7aa19d32cb5f8a9b49fc550d7b6a97624e"></a>ALIAS_PREFIX&#160;</td><td class="fielddoc"><p>the character for alias prefix <code>*</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a4bc4a2cd852d6d355e7e6f8ed183b526"></a>YAML_VER_DIRECTIVE&#160;</td><td class="fielddoc"><p>a YAML version directive found. use get_yaml_version() to get a value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a245746579c7425e28c646fe2025a7a13"></a>TAG_DIRECTIVE&#160;</td><td class="fielddoc"><p>a TAG directive found. use GetTagInfo() to get the tag information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7afe2109d3d2eb7f07dfa579496f09c587"></a>TAG_PREFIX&#160;</td><td class="fielddoc"><p>the character for tag prefix <code>!</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7ac9a9219dfe74bd3ad1c359a2f1082822"></a>INVALID_DIRECTIVE&#160;</td><td class="fielddoc"><p>an invalid directive found. do not try to get the value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7ab3302bb793d4184a5b03f59c40524324"></a>SEQUENCE_BLOCK_PREFIX&#160;</td><td class="fielddoc"><p>the character for sequence block prefix <code>-</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a715aa81f74f0c2154ab2731e3bc1740d"></a>SEQUENCE_FLOW_BEGIN&#160;</td><td class="fielddoc"><p>the character for sequence flow begin <code>[</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a094b4c8fb93f5caecb434009ad980bf2"></a>SEQUENCE_FLOW_END&#160;</td><td class="fielddoc"><p>the character for sequence flow end <code>]</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a2145e9ac1e0a05896ce1ffd6b409da9d"></a>MAPPING_FLOW_BEGIN&#160;</td><td class="fielddoc"><p>the character for mapping begin <code>{</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a08f9b8d85b2c451766f5ce81a299e104"></a>MAPPING_FLOW_END&#160;</td><td class="fielddoc"><p>the character for mapping end <code>}</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a949110ba2f21240c4a046e088b372b4b"></a>PLAIN_SCALAR&#160;</td><td class="fielddoc"><p>plain (unquoted) scalars </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a1067fbcafdf2ec86bff934d9532a7d29"></a>SINGLE_QUOTED_SCALAR&#160;</td><td class="fielddoc"><p>single-quoted scalars </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7adce0c8918a558088f218a6c99841d04b"></a>DOUBLE_QUOTED_SCALAR&#160;</td><td class="fielddoc"><p>double-quoted scalars </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a6bb661cb9de73d3ef01bf5cd6ca0197b"></a>BLOCK_LITERAL_SCALAR&#160;</td><td class="fielddoc"><p>block literal style scalars </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a9c2859e65b5ae63faccaabffcc8cae7f"></a>BLOCK_FOLDED_SCALAR&#160;</td><td class="fielddoc"><p>block folded style scalars </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a709103f395d7eda391d0f333d58083db"></a>END_OF_DIRECTIVES&#160;</td><td class="fielddoc"><p>the end of declaration of directives specified by <code>---</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ceb55f511a84f394fedd24623b92da7a6447443a57d51c89977c8e5f4810be60"></a>END_OF_DOCUMENT&#160;</td><td class="fielddoc"><p>the end of a YAML document specified by <code>...</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a79c260e5d2614f91330c3a14bb3dbc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c260e5d2614f91330c3a14bb3dbc69">&#9670;&nbsp;</a></span>node_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of node value types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69a2cb198a10d0a4c217ff4c15e98a97215"></a>SEQUENCE&#160;</td><td class="fielddoc"><p>sequence value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69a2fa399f11879d3347f324fe703fb9f97"></a>MAPPING&#160;</td><td class="fielddoc"><p>mapping value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69a196d5ef10ed279d398e255615a96e3c8"></a>NULL_OBJECT&#160;</td><td class="fielddoc"><p>null value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69ac48d5da12d702e73d6966069f2687376"></a>BOOLEAN&#160;</td><td class="fielddoc"><p>boolean value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69a5d5cd46919fa987731fb2edefe0f2a0c"></a>INTEGER&#160;</td><td class="fielddoc"><p>integer value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69a6917258a465575b46ffac54438f015f0"></a>FLOAT_NUMBER&#160;</td><td class="fielddoc"><p>float number value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c260e5d2614f91330c3a14bb3dbc69a63b588d5559f64f89a416e656880b949"></a>STRING&#160;</td><td class="fielddoc"><p>string value type </p>
</td></tr>
</table>

</div>
</div>
<a id="a881d85c4d69a945b007a50acdff3a238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881d85c4d69a945b007a50acdff3a238">&#9670;&nbsp;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238a2cb198a10d0a4c217ff4c15e98a97215"></a>SEQUENCE&#160;</td><td class="fielddoc"><p>sequence value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238a2fa399f11879d3347f324fe703fb9f97"></a>MAPPING&#160;</td><td class="fielddoc"><p>mapping value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238a196d5ef10ed279d398e255615a96e3c8"></a>NULL_OBJECT&#160;</td><td class="fielddoc"><p>null value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238ac48d5da12d702e73d6966069f2687376"></a>BOOLEAN&#160;</td><td class="fielddoc"><p>boolean value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238a5d5cd46919fa987731fb2edefe0f2a0c"></a>INTEGER&#160;</td><td class="fielddoc"><p>integer value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238ae738c26bf4ce1037fa81b039a915cbf6"></a>FLOAT&#160;</td><td class="fielddoc"><p>float point value type </p>
</td></tr>
<tr><td class="fieldname"><a id="a881d85c4d69a945b007a50acdff3a238a63b588d5559f64f89a416e656880b949"></a>STRING&#160;</td><td class="fielddoc"><p>string value type </p>
</td></tr>
</table>

</div>
</div>
<a id="a7d6168e828235e127d08d4e2db07bf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6168e828235e127d08d4e2db07bf78">&#9670;&nbsp;</a></span>tag_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a7d6168e828235e127d08d4e2db07bf78">tag_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of YAML tag types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>Represents a non-specific tag "?". </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78a3310eb2b813439167fac6b109b3708bf"></a>NON_SPECIFIC&#160;</td><td class="fielddoc"><p>Represents a non-specific tag "!". </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78adeaa0224caf9e2728caefadd911896bf"></a>CUSTOM_TAG&#160;</td><td class="fielddoc"><p>Represents a custom tag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78a2cb198a10d0a4c217ff4c15e98a97215"></a>SEQUENCE&#160;</td><td class="fielddoc"><p>Represents a sequence tag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78a2fa399f11879d3347f324fe703fb9f97"></a>MAPPING&#160;</td><td class="fielddoc"><p>Represents a mapping tag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78aa9f0aff2067f91437e50e4872b229e6a"></a>NULL_VALUE&#160;</td><td class="fielddoc"><p>Represents a null value tag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78ac48d5da12d702e73d6966069f2687376"></a>BOOLEAN&#160;</td><td class="fielddoc"><p>Represents a boolean tag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78a5d5cd46919fa987731fb2edefe0f2a0c"></a>INTEGER&#160;</td><td class="fielddoc"><p>Represents an integer type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78a0cbd694d6a73cd1a32ccfac49adc5aba"></a>FLOATING_NUMBER&#160;</td><td class="fielddoc"><p>Represents a floating point number tag. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d6168e828235e127d08d4e2db07bf78a63b588d5559f64f89a416e656880b949"></a>STRING&#160;</td><td class="fielddoc"><p>Represents a string tag. </p>
</td></tr>
</table>

</div>
</div>
<a id="a36e8fa6d8c5f31d8eb035926b6daf081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e8fa6d8c5f31d8eb035926b6daf081">&#9670;&nbsp;</a></span>utf_encode_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081">utf_encode_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of Unicode encoding types. </p>
<dl class="section note"><dt>Note</dt><dd>Since fkYAML doesn't treat UTF-16/UTF-32 encoded characters per byte, endians do not matter. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a36e8fa6d8c5f31d8eb035926b6daf081ad12edd24928a1130b74c1663a4391d24"></a>UTF_8&#160;</td><td class="fielddoc"><p>UTF-8. </p>
</td></tr>
<tr><td class="fieldname"><a id="a36e8fa6d8c5f31d8eb035926b6daf081af0353e63e27d6fc7704373c223db6d84"></a>UTF_16BE&#160;</td><td class="fielddoc"><p>UTF-16 Big Endian. </p>
</td></tr>
<tr><td class="fieldname"><a id="a36e8fa6d8c5f31d8eb035926b6daf081a986a072862269ae269f8e5d5d528a240"></a>UTF_16LE&#160;</td><td class="fielddoc"><p>UTF-16 Little Endian. </p>
</td></tr>
<tr><td class="fieldname"><a id="a36e8fa6d8c5f31d8eb035926b6daf081a392fc455715b4900922f22c51ff07af8"></a>UTF_32BE&#160;</td><td class="fielddoc"><p>UTF-32 Big Endian. </p>
</td></tr>
<tr><td class="fieldname"><a id="a36e8fa6d8c5f31d8eb035926b6daf081a07994caf33e677baa209ecf7ee18d5df"></a>UTF_32LE&#160;</td><td class="fielddoc"><p>UTF-32 Little Endian. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0a4dc98d9921c270f750a2a1a16db7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4dc98d9921c270f750a2a1a16db7f1">&#9670;&nbsp;</a></span>yaml_version_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">yaml_version_t</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of YAML version types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a4dc98d9921c270f750a2a1a16db7f1ad3045c1425531ed63ca231cb15912ac0"></a>VER_1_1&#160;</td><td class="fielddoc"><p>YAML version 1.1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a4dc98d9921c270f750a2a1a16db7f1a11400a1295bbbfcbe91a1380b7d2d576"></a>VER_1_2&#160;</td><td class="fielddoc"><p>YAML version 1.2. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3bda996ce6a4874f26ec3e41b9bbed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bda996ce6a4874f26ec3e41b9bbed12">&#9670;&nbsp;</a></span>yaml_version_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3bda996ce6a4874f26ec3e41b9bbed12ab4abd26b93226f8ce368709dd09c1eb7"></a>VERSION_1_1&#160;</td><td class="fielddoc"><p>YAML version 1.1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3bda996ce6a4874f26ec3e41b9bbed12a5e2745357f1c8b7db5eb87d3c4fa8276"></a>VERSION_1_2&#160;</td><td class="fielddoc"><p>YAML version 1.2. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a407416834912e052f6c9d2df7fa1158e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407416834912e052f6c9d2df7fa1158e">&#9670;&nbsp;</a></span>atob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharItr , typename BoolType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atob </td>
          <td>(</td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoolType &amp;&#160;</td>
          <td class="paramname"><em>boolean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into a boolean value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharItr</td><td>The type of char iterators. Its value type must be <code>char</code> (maybe cv-qualified). </td></tr>
    <tr><td class="paramname">BoolType</td><td>The output boolean type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator to the first element of the scalar. </td></tr>
    <tr><td class="paramname">end</td><td>The iterator to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">boolean</td><td>The boolean value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a7f880e86dacd75b2acfa6bd496fd5f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f880e86dacd75b2acfa6bd496fd5f8c">&#9670;&nbsp;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharItr , typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atof </td>
          <td>(</td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into a floating point value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharItr</td><td>The type of char iterators. Its value type must be char (maybe cv-qualified). </td></tr>
    <tr><td class="paramname">FloatType</td><td>The output floating point value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator to the first element of the scalar. </td></tr>
    <tr><td class="paramname">end</td><td>The iterator to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">f</td><td>The output floating point value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="abbfcf131f3ab958ee6a64124709ce262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfcf131f3ab958ee6a64124709ce262">&#9670;&nbsp;</a></span>atof_impl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atof_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into a <code>double</code> value. </p>
<dl class="section warning"><dt>Warning</dt><dd><code>p_begin</code> and <code>p_end</code> must not be null. Validate them before calling this function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">f</td><td>The output <code>double</code> value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="aa0559d8ae0567d95092047d4b2ffc89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0559d8ae0567d95092047d4b2ffc89a">&#9670;&nbsp;</a></span>atof_impl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atof_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into a <code>float</code> value. </p>
<dl class="section warning"><dt>Warning</dt><dd><code>p_begin</code> and <code>p_end</code> must not be null. Validate them before calling this function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">f</td><td>The output <code>float</code> value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="ab824250dc8d429b714badf711ca8c6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab824250dc8d429b714badf711ca8c6d0">&#9670;&nbsp;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharItr , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atoi </td>
          <td>(</td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into integers. </p>
<p>This function executes bounds check to avoid overflow/underflow. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharItr</td><td>The type of char iterators. Its value type must be char (maybe cv-qualified). </td></tr>
    <tr><td class="paramname">IntType</td><td>The output integer type. It can be either signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator to the first element of the scalar. </td></tr>
    <tr><td class="paramname">end</td><td>The iterator to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The output integer value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a86c6ec43248fb527250ec8f6d1aa562a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c6ec43248fb527250ec8f6d1aa562a">&#9670;&nbsp;</a></span>atoi_dec_neg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atoi_dec_neg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into negative decimals. </p>
<p>This function executes bounds check to avoid underflow. </p><dl class="section warning"><dt>Warning</dt><dd><code>p_begin</code> and <code>p_end</code> must not be null. Validate them before calling this function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>The output integer type. It must be signed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The output integer value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a68044668c544bc95d107d7c1877ad255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68044668c544bc95d107d7c1877ad255">&#9670;&nbsp;</a></span>atoi_dec_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atoi_dec_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into positive decimals. </p>
<p>This function executes bounds check to avoid overflow. </p><dl class="section warning"><dt>Warning</dt><dd><code>p_begin</code> and <code>p_end</code> must not be null. Validate them before calling this function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>The output integer type. It can be either signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The output integer value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a2c19dc5ee52703d61ea795aaa3c6cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c19dc5ee52703d61ea795aaa3c6cbc3">&#9670;&nbsp;</a></span>atoi_dec_unchecked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atoi_dec_unchecked </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into decimals. </p>
<p>This is common implementation for both signed/unsigned integer types. </p><dl class="section warning"><dt>Warning</dt><dd>This function does NOT care about overflows if IntType is unsigned. The source string value must be validated beforehand by calling either <a class="el" href="node_8hpp.html#a68044668c544bc95d107d7c1877ad255" title="Converts a scalar into positive decimals.">atoi_dec_pos()</a> or <a class="el" href="node_8hpp.html#a86c6ec43248fb527250ec8f6d1aa562a" title="Converts a scalar into negative decimals.">atoi_dec_neg()</a> functions. Furthermore, <code>p_begin</code> and <code>p_end</code> must NOT be null. Validate them before calling this function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>The output integer type. It can be either signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The output integer value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a4f472c0e6d68778599ab1ebf91678c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f472c0e6d68778599ab1ebf91678c3e">&#9670;&nbsp;</a></span>atoi_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atoi_hex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into hexadecimals. </p>
<p>This function executes bounds check to avoid overflow. </p><dl class="section warning"><dt>Warning</dt><dd><code>p_begin</code> and <code>p_end</code> must not be null. Validate them before calling this function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>The output integer type. It can be either signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The output integer value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a3d37d989b14246546efcde4048570371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d37d989b14246546efcde4048570371">&#9670;&nbsp;</a></span>atoi_oct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool atoi_oct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into octals. </p>
<p>This function executes bounds check to avoid overflow. </p><dl class="section warning"><dt>Warning</dt><dd><code>p_begin</code> and <code>p_end</code> must not be null. Validate them before calling this function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>The output integer type. It can be either signed or unsigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_begin</td><td>The pointer to the first element of the scalar. </td></tr>
    <tr><td class="paramname">p_end</td><td>The pointer to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">i</td><td>The output integer value holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="adf750e9f3995dfa48df7bbad443c087f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf750e9f3995dfa48df7bbad443c087f">&#9670;&nbsp;</a></span>aton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharItr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool aton </td>
          <td>(</td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharItr&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a scalar into a null value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharItr</td><td>Type of char iterators. Its value type must be <code>char</code> (maybe cv-qualified). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator to the first element of the scalar. </td></tr>
    <tr><td class="paramname">end</td><td>The iterator to the past-the-end element of the scalar. </td></tr>
    <tr><td class="paramname">/*unused*&amp;zwj;/</td><td>The null value holder (unused since it can only have <code>nullptr</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the conversion completes successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a87a0f3d345d6af75503ed4966a0f6175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a0f3d345d6af75503ed4966a0f6175">&#9670;&nbsp;</a></span>convert_from_node_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a> convert_from_node_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ae6d843f6f02257158312b1d6b819dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae6d843f6f02257158312b1d6b819dd">&#9670;&nbsp;</a></span>convert_from_yaml_version_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">yaml_version_t</a> convert_from_yaml_version_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e448edff68fac084e9967c004d1a669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e448edff68fac084e9967c004d1a669">&#9670;&nbsp;</a></span>convert_to_node_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a> convert_to_node_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c8290add221fab99a59ea12426adf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8290add221fab99a59ea12426adf16">&#9670;&nbsp;</a></span>convert_to_yaml_version_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a> convert_to_yaml_version_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a0a4dc98d9921c270f750a2a1a16db7f1">yaml_version_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c87ddd8cc61a5140db7fed537568a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c87ddd8cc61a5140db7fed537568a35">&#9670;&nbsp;</a></span>create_iterator_input_adapter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItrType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a>&lt;ItrType&gt; create_iterator_input_adapter </td>
          <td>(</td>
          <td class="paramtype">ItrType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItrType&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_contiguous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A concrete factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ItrType</td><td>An iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of iterators. </td></tr>
    <tr><td class="paramname">end</td><td>The end of iterators. </td></tr>
    <tr><td class="paramname">is_contiguous</td><td>Whether iterators refer to a contiguous byte array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> object for the target iterator type. </dd></dl>

</div>
</div>
<a id="ac6de76a90a8fda06d8b0b38f88c50590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6de76a90a8fda06d8b0b38f88c50590">&#9670;&nbsp;</a></span>detect_encoding_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#ab8cc808373a7ff2e6615c65c32675dd7">FK_YAML_DETAIL_NAMESPACE_END</a> <a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a> <a class="el" href="node_8hpp.html#a36e8fa6d8c5f31d8eb035926b6daf081">utf_encode_t</a> detect_encoding_type </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; uint8_t, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>has_bom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect an encoding type for UTF-8 expected inputs. </p>
<dl class="section note"><dt>Note</dt><dd>This function doesn't support the case where the first character is null. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>4 bytes of an input character sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">has_bom</td><td>Whether the input contains a BOM. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A detected encoding type. </dd></dl>

</div>
</div>
<a id="a080bd0fe1a31859ecfd4d6fe93424385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080bd0fe1a31859ecfd4d6fe93424385">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a> std::string format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ea21001d797388e4a404f87084c2624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea21001d797388e4a404f87084c2624">&#9670;&nbsp;</a></span>from_node() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for booleans. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A node object. </td></tr>
    <tr><td class="paramname">b</td><td>Storage for a boolean value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd049c3aaad326f4edde88c0d97f86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd049c3aaad326f4edde88c0d97f86d">&#9670;&nbsp;</a></span>from_node() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename CompatibleStringType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, negation&lt; std::is_same&lt; CompatibleStringType, typename BasicNodeType::string_type &gt;&gt;, disjunction&lt; std::is_constructible&lt; CompatibleStringType, const typename BasicNodeType::string_type &amp; &gt;, std::is_assignable&lt; CompatibleStringType, const typename BasicNodeType::string_type &amp; &gt;&gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompatibleStringType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for compatible string type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">CompatibleStringType</td><td>A compatible string type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">s</td><td>A compatible string object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79df658bd9bd2fdf6909d0618a5ebafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79df658bd9bd2fdf6909d0618a5ebafb">&#9670;&nbsp;</a></span>from_node() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename CompatMapType , enable_if_t&lt; is_constructible_mapping_type&lt; CompatMapType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompatMapType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::declval&lt;const BasicNodeType &amp;&gt;()
                    .template get_value&lt;typename CompatMapType::key_type&gt;(),
                std::declval&lt;const BasicNodeType &amp;&gt;()
                    .template get_value&lt;typename CompatMapType::mapped_type&gt;(),
                m.emplace(std::declval&lt;typename CompatMapType::key_type&gt;(),
                          std::declval&lt;typename CompatMapType::mapped_type&gt;()),
                void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for mappings whose key and value are of both compatible types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">CompatibleKeyType</td><td>Mapping key type compatible with BasicNodeType. </td></tr>
    <tr><td class="paramname">CompatibleValueType</td><td>Mapping value type compatible with BasicNodeType. </td></tr>
    <tr><td class="paramname">Compare</td><td>Comparator type for mapping keys. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Allocator type for destination mapping object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A node object. </td></tr>
    <tr><td class="paramname">m</td><td>Mapping container object to store converted key/value objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a011b78a17b1e0b8b7963d5f88eac48af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011b78a17b1e0b8b7963d5f88eac48af">&#9670;&nbsp;</a></span>from_node() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename CompatSeqType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, is_constructible_sequence_type&lt; BasicNodeType, CompatSeqType &gt;, negation&lt; std::is_constructible&lt; typename BasicNodeType::string_type, CompatSeqType &gt;&gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompatSeqType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.template get_value&lt;typename CompatSeqType::value_type&gt;(), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for container objects of only keys or values, e.g., std::vector or std::set, whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">CompatSeqType</td><td>A container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">s</td><td>A container object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72213774bf1c36d073223360a89404c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72213774bf1c36d073223360a89404c5">&#9670;&nbsp;</a></span>from_node() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename FloatType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_floating_point&lt; FloatType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatType &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for floating point values. </p>
<dl class="section note"><dt>Note</dt><dd>If node's value is null, boolean, or integer, such a value is converted into a floating point internally. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">FloatType</td><td>A floating point value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A node object. </td></tr>
    <tr><td class="paramname">f</td><td>Storage for a float point value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fca29e5a2225fd45d3044ff619b5d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fca29e5a2225fd45d3044ff619b5d33">&#9670;&nbsp;</a></span>from_node() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename IntegerType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, is_non_bool_integral&lt; IntegerType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for integers. </p>
<dl class="section note"><dt>Note</dt><dd>If node's value is null, boolean, or float, such a value is converted into an integer internally. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">IntegerType</td><td>An integer value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A node object. </td></tr>
    <tr><td class="paramname">i</td><td>Storage for an integer value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb4610f520dd0300959fbd5c94ccdcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4610f520dd0300959fbd5c94ccdcdc">&#9670;&nbsp;</a></span>from_node() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename SeqContainerAdapter , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, is_sequence_container_adapter&lt; SeqContainerAdapter &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SeqContainerAdapter &amp;&#160;</td>
          <td class="paramname"><em>ca</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.template get_value&lt;typename SeqContainerAdapter::value_type&gt;(),
                ca.push(std::declval&lt;typename SeqContainerAdapter::value_type&gt;()), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for sequence container adapter objects, e.g., std::stack or std::queue, whose element type must be either a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">SeqContainerAdapter</td><td>A sequence container adapter type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A node object. </td></tr>
    <tr><td class="paramname">ca</td><td>A sequence container adapter object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acea665683f882f372a47d6260f259550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea665683f882f372a47d6260f259550">&#9670;&nbsp;</a></span>from_node() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.get_value_inplace(std::declval&lt;T &amp;&gt;()), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for std::array objects whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<p>This function is necessary since insert function is not implemented for std::array. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>Element type of std::array. </td></tr>
    <tr><td class="paramname">N</td><td>Size of std::array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">arr</td><td>A std::array object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab43611f94799f9766ee31983a727975d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43611f94799f9766ee31983a727975d">&#9670;&nbsp;</a></span>from_node() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>fl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.template get_value&lt;T&gt;(), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for std::forward_list objects whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<p>This function is necessary since insert function is not implemented for std::forward_list. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>Element type of std::forward_list. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator type of std::forward_list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">fl</td><td>A std::forward_list object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17a48dfab59d6a36cbfe59a371c81a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a48dfab59d6a36cbfe59a371c81a58">&#9670;&nbsp;</a></span>from_node() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for nullptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A node object. </td></tr>
    <tr><td class="paramname">null</td><td>Storage for a null value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f0dde966166084faa12789807edf923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0dde966166084faa12789807edf923">&#9670;&nbsp;</a></span>from_node() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , typename U , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::declval&lt;const BasicNodeType &amp;&gt;().template get_value&lt;T&gt;(),
                std::declval&lt;const BasicNodeType &amp;&gt;().template get_value&lt;U&gt;(), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for std::pair objects whose element types must be either a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>The first type of the std::pair. </td></tr>
    <tr><td class="paramname">U</td><td>The second type of the std::pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">p</td><td>A std::pair object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cb5527cd21e5e57efdcbcb6d5de5750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb5527cd21e5e57efdcbcb6d5de5750">&#9670;&nbsp;</a></span>from_node() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename... Types, enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for std::tuple objects whose value types must all be either a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">...Types</td><td>Value types of std::tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">t</td><td>A std::tuple object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab12c5bde31d20ab00af457554838c81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12c5bde31d20ab00af457554838c81d">&#9670;&nbsp;</a></span>from_node() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.get_value_inplace(std::declval&lt;T &amp;&gt;()), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for std::valarray objects whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<p>This function is necessary since insert function is not implemented for std::valarray. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>Element type of std::valarray. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">va</td><td>A std::valarray object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a203303bf1b8f348a4414a60d180d0353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203303bf1b8f348a4414a60d180d0353">&#9670;&nbsp;</a></span>from_node() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , std::size_t N0, std::size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N0][N1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.get_value_inplace(std::declval&lt;T &amp;&gt;()), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for C-style 2D arrays whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>Element type of C-style 2D array. </td></tr>
    <tr><td class="paramname">N0</td><td>Size of the outer dimension. </td></tr>
    <tr><td class="paramname">N1</td><td>Size of the inner dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">array</td><td>An array object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7d5a2217392100beb5f979cebc0c5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d5a2217392100beb5f979cebc0c5c1">&#9670;&nbsp;</a></span>from_node() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , std::size_t N0, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N0][N1][N2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.get_value_inplace(std::declval&lt;T &amp;&gt;()), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for C-style 2D arrays whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>Element type of C-style 2D array. </td></tr>
    <tr><td class="paramname">N0</td><td>Size of the outermost dimension. </td></tr>
    <tr><td class="paramname">N1</td><td>Size of the middle dimension. </td></tr>
    <tr><td class="paramname">N2</td><td>Size of the innermost dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">array</td><td>An array object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad0d5c40a6de221a83f83e64b65632c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0d5c40a6de221a83f83e64b65632c2">&#9670;&nbsp;</a></span>from_node() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n.get_value_inplace(std::declval&lt;T &amp;&gt;()), void())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for C-style 1D arrays whose element type must be a <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type or a compatible type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>Element type of C-style 1D array. </td></tr>
    <tr><td class="paramname">N</td><td>Size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">array</td><td>An array object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecb405949c717ffa8f81bfd67cf6d13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb405949c717ffa8f81bfd67cf6d13f">&#9670;&nbsp;</a></span>from_node() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void from_node </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BasicNodeType::string_type &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>from_node function for BasicNodeType::string_type objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">s</td><td>A string node value object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb467a36467945fd28bcd3a3dbc9edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb467a36467945fd28bcd3a3dbc9edc2">&#9670;&nbsp;</a></span>from_node_tuple_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename... Types, std::size_t... Idx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;Types...&gt; from_node_tuple_impl </td>
          <td>(</td>
          <td class="paramtype">const BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a961d746437c4b43a508e8841f4c5c6c4">index_sequence</a>&lt; Idx... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>concrete implementation of from_node function for std::tuple objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">...Types</td><td>The value types of std::tuple. </td></tr>
    <tr><td class="paramname">...Idx</td><td>Index sequence values for std::tuples value types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object </td></tr>
    <tr><td class="paramname">_</td><td>Index sequence values (unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::tuple object converted from the sequence node values. </dd></dl>

</div>
</div>
<a id="a3647c7f6557332490e9835c478745fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3647c7f6557332490e9835c478745fb7">&#9670;&nbsp;</a></span>input_adapter() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinput__adapter__factory_1_1container__input__adapter__factory.html">input_adapter_factory::container_input_adapter_factory</a>&lt;ContainerType&gt;::adapter_type input_adapter </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerType</td><td>A container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A container object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input_adapter_factory::container_input_adapter_factory&lt;ContainerType&gt;::adapter_type </dd></dl>

</div>
</div>
<a id="a156e537c246c50d9586cd12f9dca0b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156e537c246c50d9586cd12f9dca0b58">&#9670;&nbsp;</a></span>input_adapter() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItrType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a>&lt;ItrType&gt; input_adapter </td>
          <td>(</td>
          <td class="paramtype">ItrType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItrType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with iterator values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ItrType</td><td>An iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of iterators. </td></tr>
    <tr><td class="paramname">end</td><td>The end of iterators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator_input_adapter&lt;ItrType&gt; An <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> object for the target iterator type. </dd></dl>

</div>
</div>
<a id="af4ca0bd6f4f7a1d2f056e77b0b97c8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ca0bd6f4f7a1d2f056e77b0b97c8b2">&#9670;&nbsp;</a></span>input_adapter() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfile__input__adapter.html">file_input_adapter</a> input_adapter </td>
          <td>(</td>
          <td class="paramtype">std::FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factory method for <a class="el" href="classfile__input__adapter.html" title="An input adapter for C-style file handles.">file_input_adapter</a> objects with C-style file handles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>A file handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classfile__input__adapter.html" title="An input adapter for C-style file handles.">file_input_adapter</a> A <a class="el" href="classfile__input__adapter.html" title="An input adapter for C-style file handles.">file_input_adapter</a> object. </dd></dl>

</div>
</div>
<a id="af703e0ffe80be5f9a9a6cc2c1dc5169a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af703e0ffe80be5f9a9a6cc2c1dc5169a">&#9670;&nbsp;</a></span>input_adapter() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstream__input__adapter.html">stream_input_adapter</a> input_adapter </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factory method for <a class="el" href="classstream__input__adapter.html" title="An input adapter for streams.">stream_input_adapter</a> objects with std::istream objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>An input stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classstream__input__adapter.html" title="An input adapter for streams.">stream_input_adapter</a> A <a class="el" href="classstream__input__adapter.html" title="An input adapter for streams.">stream_input_adapter</a> object. </dd></dl>

</div>
</div>
<a id="a0fcf5ce57960cc91c427eaf5264d2377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcf5ce57960cc91c427eaf5264d2377">&#9670;&nbsp;</a></span>input_adapter() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto input_adapter </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="node_8hpp.html#a5c87ddd8cc61a5140db7fed537568a35">create_iterator_input_adapter</a>(array, array + (N - 1), true))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factory method for <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> objects with C-style arrays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type of arrayed objects. </td></tr>
    <tr><td class="paramname">N</td><td>A size of an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decltype(input_adapter(array, array + N)) An <a class="el" href="classiterator__input__adapter.html">iterator_input_adapter</a> object for the target array. </dd></dl>

</div>
</div>
<a id="a8c25e15264dc232b05aa2f8c04c738a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c25e15264dc232b05aa2f8c04c738a6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are different, false otherwise. </dd></dl>

</div>
</div>
<a id="a306ab36f4b207c85b76a9381d32079bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306ab36f4b207c85b76a9381d32079bb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT(&amp;)&#160;</td>
          <td class="paramname"><em>rhs</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
    <tr><td class="paramname">N</td><td>The length of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A character array to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are different, false otherwise. </dd></dl>

</div>
</div>
<a id="ac3648615788af27dad431b27984526c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3648615788af27dad431b27984526c2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A basic_string object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are different, false otherwise. </dd></dl>

</div>
</div>
<a id="a5b4c76d958de4f8fb0e037003a2b2027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4c76d958de4f8fb0e037003a2b2027">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const CharT(&amp;)&#160;</td>
          <td class="paramname"><em>lhs</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
    <tr><td class="paramname">N</td><td>The length of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>A character array for comparison. </td></tr>
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are different, false otherwise. </dd></dl>

</div>
</div>
<a id="ad5e17c1b3969098e06bcb7fd946edc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e17c1b3969098e06bcb7fd946edc9d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorL , typename IteratorR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a177312a4feaaffcb455795a1fef214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a177312a4feaaffcb455795a1fef214">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An not-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A basic_string object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are different, false otherwise. </dd></dl>

</div>
</div>
<a id="aeac030c1203c78961571cf965abfb375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac030c1203c78961571cf965abfb375">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An less-than operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>lhs</code> is less than <code>rhs</code>, false otherwise. </dd></dl>

</div>
</div>
<a id="a049293eb0eb750086eba27100580ed2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049293eb0eb750086eba27100580ed2a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorL , typename IteratorR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ab4bba30e7d61f15a8c5872a29bea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ab4bba30e7d61f15a8c5872a29bea1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>sv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type. </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>An output stream object. </td></tr>
    <tr><td class="paramname">sv</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream object <code>os</code>. </dd></dl>

</div>
</div>
<a id="a1e2ca7a9017b457d014fdd166589175f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2ca7a9017b457d014fdd166589175f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename... &gt; class SequenceType, template&lt; typename, typename, typename... &gt; class MappingType, typename BooleanType , typename IntegerType , typename FloatNumberType , typename StringType , template&lt; typename, typename=void &gt; class ConverterType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion operator for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template class. </p>
<p>A wrapper for the serialization feature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>An output stream object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream object <code>os</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://fktn-k.github.io/fkYAML/api/basic_node/insertion_operator/">https://fktn-k.github.io/fkYAML/api/basic_node/insertion_operator/</a> </dd></dl>

</div>
</div>
<a id="a31e5a95d6d2d174506bb170137e05a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e5a95d6d2d174506bb170137e05a15">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An less-than-or-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>lhs</code> is less than or equal to <code>rhs</code>, false otherwise. </dd></dl>

</div>
</div>
<a id="a3dd519e927cc2a82af686706a53ef9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd519e927cc2a82af686706a53ef9c6">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorL , typename IteratorR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf9ae1d88ac076f895fcd1da0332a77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9ae1d88ac076f895fcd1da0332a77f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="a3aa4e4d656b1145e9926a83e8a31f382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa4e4d656b1145e9926a83e8a31f382">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT(&amp;)&#160;</td>
          <td class="paramname"><em>rhs</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
    <tr><td class="paramname">N</td><td>The length of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A character array to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="ab0d30d2909ef9980b0adcaec96f1d5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d30d2909ef9980b0adcaec96f1d5d4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A basic_string object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="ae3607abeabbeec28c649eb1b492a3232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3607abeabbeec28c649eb1b492a3232">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const CharT(&amp;)&#160;</td>
          <td class="paramname"><em>lhs</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
    <tr><td class="paramname">N</td><td>The length of the character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>A character array for comparison. </td></tr>
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="a9437fc9d4044aa1c12ba6ec8517fb176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9437fc9d4044aa1c12ba6ec8517fb176">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorL , typename IteratorR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acad6a835351b58683eb81b5dd899805f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad6a835351b58683eb81b5dd899805f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A basic_string object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two objects are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="afc35fa4ea827bf42466e1e056f736720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc35fa4ea827bf42466e1e056f736720">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An greater-than operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>lhs</code> is greater than <code>rhs</code>, false otherwise. </dd></dl>

</div>
</div>
<a id="a54918863d13121bea9f8e12e3a67b5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54918863d13121bea9f8e12e3a67b5c6">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorL , typename IteratorR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c94f5b59efcb4c687dba416785d5ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c94f5b59efcb4c687dba416785d5ecf">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__str__view.html">basic_str_view</a>&lt; CharT, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An greater-than-or-equal-to operator of the <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Character type </td></tr>
    <tr><td class="paramname">Traits</td><td>Character traits type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object for comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>A <a class="el" href="classbasic__str__view.html" title="Non owning view into constant character sequence.">basic_str_view</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>lhs</code> is greater than or equal to <code>rhs</code>, false otherwise. </dd></dl>

</div>
</div>
<a id="ac2a95142255f79a218825a934f36935e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a95142255f79a218825a934f36935e">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorL , typename IteratorR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreverse__iterator.html">reverse_iterator</a>&lt; IteratorR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa91c8117a14a778eead725f90bcb6b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91c8117a14a778eead725f90bcb6b3f">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename... &gt; class SequenceType, template&lt; typename, typename, typename... &gt; class MappingType, typename BooleanType , typename IntegerType , typename FloatNumberType , typename StringType , template&lt; typename, typename=void &gt; class ConverterType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extraction operator for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template class. </p>
<p>A wrapper for the deserialization feature with input streams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is</td><td>An input stream object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the input stream object <code>is</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://fktn-k.github.io/fkYAML/api/basic_node/extraction_operator/">https://fktn-k.github.io/fkYAML/api/basic_node/extraction_operator/</a> </dd></dl>

</div>
</div>
<a id="a6cff770c980f926ed26bbbd642c2d0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cff770c980f926ed26bbbd642c2d0b6">&#9670;&nbsp;</a></span>set_infinity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_infinity </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an infinite <code>double</code> value based on the given signedness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The output <code>double</code> value holder. </td></tr>
    <tr><td class="paramname">sign</td><td>Whether the infinite value should be positive or negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3a222a41f9b400287a99ade41820af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a222a41f9b400287a99ade41820af1">&#9670;&nbsp;</a></span>set_infinity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_infinity </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an infinite <code>float</code> value based on the given signedness. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The output <code>float</code> value holder. </td></tr>
    <tr><td class="paramname">sign</td><td>Whether the infinite value should be positive or negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30a8ca42d762a253f0d1f7cdd2f2c281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a8ca42d762a253f0d1f7cdd2f2c281">&#9670;&nbsp;</a></span>set_nan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_nan </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a NaN <code>double</code> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The output <code>double</code> value holder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51465e1fa382ddba53933393ed698818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51465e1fa382ddba53933393ed698818">&#9670;&nbsp;</a></span>set_nan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_nan </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a NaN <code>float</code> value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The output <code>float</code> value holder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec92720797c84629d71585fb7fcc5bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec92720797c84629d71585fb7fcc5bce">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename... &gt; class SequenceType, template&lt; typename, typename, typename... &gt; class MappingType, typename BooleanType , typename IntegerType , typename FloatNumberType , typename StringType , template&lt; typename, typename=void &gt; class ConverterType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__node.html">basic_node</a>&lt; SequenceType, MappingType, BooleanType, IntegerType, FloatNumberType, StringType, ConverterType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap function for <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>A left-side-hand <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object to be swapped with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>A right-side-hand <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object to be swapped with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://fktn-k.github.io/fkYAML/api/swap/">https://fktn-k.github.io/fkYAML/api/swap/</a> </dd></dl>

</div>
</div>
<a id="a2cb24307dc5efef0c8f2b52e57a986f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb24307dc5efef0c8f2b52e57a986f6">&#9670;&nbsp;</a></span>to_node() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, negation&lt; is_null_pointer&lt; T &gt;&gt;, std::is_constructible&lt; typename BasicNodeType::string_type, const T &amp; &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_node </td>
          <td>(</td>
          <td class="paramtype">BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to_node function for compatible strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>A compatible string type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">s</td><td>A compatible string object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a978ce708d868cad0027e88d327d860f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978ce708d868cad0027e88d327d860f4">&#9670;&nbsp;</a></span>to_node() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename NullType , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_same&lt; NullType, std::nullptr_t &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_node </td>
          <td>(</td>
          <td class="paramtype">BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to_node function for null objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A mapping node value type. </td></tr>
    <tr><td class="paramname">NullType</td><td>This must be std::nullptr_t type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb3731d43aae60ea565195dc7d0722e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3731d43aae60ea565195dc7d0722e1">&#9670;&nbsp;</a></span>to_node() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_same&lt; typename BasicNodeType::sequence_type, remove_cvref_t&lt; T &gt;&gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_node </td>
          <td>(</td>
          <td class="paramtype">BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to_node function for BasicNodeType::sequence_type objects. </p>
<p>to_node function for BasicNodeType::mapping_type objects.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>A sequence node value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">s</td><td>A sequence node value object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>A mapping node value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">m</td><td>A mapping node value object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad288e0c5537e9b214607569bab2614e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad288e0c5537e9b214607569bab2614e1">&#9670;&nbsp;</a></span>to_node() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , typename T , enable_if_t&lt; conjunction&lt; is_basic_node&lt; BasicNodeType &gt;, std::is_same&lt; typename BasicNodeType::boolean_type, T &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_node </td>
          <td>(</td>
          <td class="paramtype">BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to_node function for BasicNodeType::boolean_type objects. </p>
<p>to_node function for floating point numbers.</p>
<p>to_node function for integers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>A boolean scalar node value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">b</td><td>A boolean scalar node value object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">i</td><td>An integer object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type. </td></tr>
    <tr><td class="paramname">T</td><td>A floating point number type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">f</td><td>A floating point number object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f7ae98d52265316a5c797c06b0cf994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7ae98d52265316a5c797c06b0cf994">&#9670;&nbsp;</a></span>to_node() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasicNodeType , enable_if_t&lt; is_basic_node&lt; BasicNodeType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_node </td>
          <td>(</td>
          <td class="paramtype">BasicNodeType &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename BasicNodeType::string_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to_node function for rvalue string node values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicNodeType</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> template instance type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A <a class="el" href="classbasic__node.html" title="A class to store value of YAML nodes.">basic_node</a> object. </td></tr>
    <tr><td class="paramname">s</td><td>An rvalue string node value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6592dfcb4b1f723556a02bc01128ed90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592dfcb4b1f723556a02bc01128ed90">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A resulting string YAML token. </td></tr>
    <tr><td class="paramname">v</td><td>A boolean source value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6074c9da5c716deed1534a06fe7ea13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6074c9da5c716deed1534a06fe7ea13b">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">enable_if_t</a>&lt;std::is_floating_point&lt;FloatType&gt;::value&gt; to_string </td>
          <td>(</td>
          <td class="paramtype">FloatType&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for floating point numbers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>A floating point number type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A resulting string YAML token. </td></tr>
    <tr><td class="paramname">f</td><td>A floating point number source value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a487dc2227c645d9124e23186d0cbe649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487dc2227c645d9124e23186d0cbe649">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a7686f4990569708f40dfde235b6c3b11">enable_if_t</a>&lt;<a class="el" href="structis__non__bool__integral.html">is_non_bool_integral</a>&lt;IntegerType&gt;::value&gt; to_string </td>
          <td>(</td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for integers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerType</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A resulting string YAML token. </td></tr>
    <tr><td class="paramname">i</td><td>An integer source value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18aa18fda8896a73b564c07839c69a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aa18fda8896a73b564c07839c69a16">&#9670;&nbsp;</a></span>to_string() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a79c260e5d2614f91330c3a14bb3dbc69">node_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a739a032ed975329a1f63b4e0e0e11e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739a032ed975329a1f63b4e0e0e11e4f">&#9670;&nbsp;</a></span>to_string() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a881d85c4d69a945b007a50acdff3a238">node_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a70ab2f61462f6c8e8f6b7eaa15d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a70ab2f61462f6c8e8f6b7eaa15d40d">&#9670;&nbsp;</a></span>to_string() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void to_string </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="node_8hpp.html#ae303a43856edd89e2f47a45be344c53c">to_string()</a> for null values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A resulting string YAML token. </td></tr>
    <tr><td class="paramname">(unused)</td><td>nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a227cd25b227590e73a65a9e8fa498c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227cd25b227590e73a65a9e8fa498c23">&#9670;&nbsp;</a></span>to_string() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8hpp.html#a8205dbc6a1114becc668105819ea1b57">FK_YAML_DETAIL_NAMESPACE_BEGIN</a> void to_string </td>
          <td>(</td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharType &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a ValueType object to a string YAML token. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>A source value type. </td></tr>
    <tr><td class="paramname">CharType</td><td>The type of characters for the conversion result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A resulting output string. </td></tr>
    <tr><td class="paramname">v</td><td>A source value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae303a43856edd89e2f47a45be344c53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae303a43856edd89e2f47a45be344c53c">&#9670;&nbsp;</a></span>to_string() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8hpp.html#a3bda996ce6a4874f26ec3e41b9bbed12">yaml_version_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98a996adc7ad22a8dc75b936e74b73ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a996adc7ad22a8dc75b936e74b73ca">&#9670;&nbsp;</a></span>unreachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unreachable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper function to call std::unreachable() (since C++23) or similar compiler specific extensions. </p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented only for better code optimization against dead code and thus excluded from coverage report. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
